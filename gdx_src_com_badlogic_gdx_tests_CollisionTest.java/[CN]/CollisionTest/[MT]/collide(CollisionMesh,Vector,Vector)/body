{
  float distToTravel=velocity.len();
  if (distToTravel < CollisionDetection.EPSILON)   return;
  boolean collisionFound=false;
  float nearestDistance=-1.0f;
  Vector nearestIntersectionPoint=new Vector();
  Vector nearestPolygonIntersectionPoint=new Vector();
  Vector p1=new Vector();
  Vector p2=new Vector();
  Vector p3=new Vector();
  Plane plane=new Plane(new Vector(),0);
  float[] triangles=mesh.getTriangles();
  int numTriangles=mesh.getNumTriangles();
  int idx=0;
  for (int i=0; i < numTriangles; i++) {
    p1.set(triangles[idx++],triangles[idx++],triangles[idx++]);
    p2.set(triangles[idx++],triangles[idx++],triangles[idx++]);
    p3.set(triangles[idx++],triangles[idx++],triangles[idx++]);
    if (mesh.isClockWise())     plane.set(p3,p2,p1);
 else     plane.set(p1,p2,p3);
    float pDist=CollisionDetection.signedDistanceToPlane(plane,origin);
    Vector sphereIntersectionPoint=new Vector();
    Vector planeIntersectionPoint=new Vector();
    if (pDist < 0)     continue;
 else     if (pDist <= 1.0) {
      Vector temp=new Vector(plane.normal).mul(-pDist);
      planeIntersectionPoint.set(origin).add(temp);
    }
 else {
      sphereIntersectionPoint.set(origin).sub(plane.normal);
      if (!CollisionDetection.intersectRayPlane(new Ray(sphereIntersectionPoint,velocity),plane,planeIntersectionPoint))       continue;
    }
    Vector polygonIntersectionPoint=new Vector(planeIntersectionPoint);
    if (!CollisionDetection.isPointInTriangle(planeIntersectionPoint,p1,p2,p3)) {
      Vector in=new Vector();
      CollisionDetection.closestPointToTriangle(p1,p2,p3,planeIntersectionPoint,in);
      polygonIntersectionPoint.set(in);
    }
    Vector in=new Vector();
    Vector negativeVelocityVector=new Vector(velocity).mul(-1);
    if (CollisionDetection.intersectRaySphere(new Ray(polygonIntersectionPoint,negativeVelocityVector),new Sphere(origin,1),in)) {
      float t=origin.dst(in);
      if (!collisionFound || t < nearestDistance) {
        nearestDistance=t;
        nearestIntersectionPoint.set(in);
        nearestPolygonIntersectionPoint.set(polygonIntersectionPoint);
        collisionFound=true;
      }
    }
  }
  if (!collisionFound)   return;
  Vector v=new Vector(velocity).nor().mul(nearestDistance - CollisionDetection.EPSILON);
  origin.add(v);
  v.nor().mul(distToTravel - nearestDistance);
  Vector destinationPoint=new Vector(nearestPolygonIntersectionPoint).add(v);
  Vector slidePlaneOrigin=new Vector(nearestPolygonIntersectionPoint);
  Vector slidePlaneNormal=new Vector(nearestPolygonIntersectionPoint).sub(origin).nor();
  float time=CollisionDetection.intersectRayPlane(new Ray(destinationPoint,slidePlaneNormal),new Plane(slidePlaneOrigin,slidePlaneNormal));
  slidePlaneNormal.nor().mul(time);
  Vector destinationProjectionNormal=new Vector(slidePlaneNormal);
  Vector newDestinationPoint=new Vector(destinationPoint).add(destinationProjectionNormal);
  Vector newVelocityVector=newDestinationPoint.sub(nearestPolygonIntersectionPoint);
  collide(mesh,origin,newVelocityVector);
}
