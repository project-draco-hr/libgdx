{
  Particle particle=particles[index];
  if (particle == null) {
    particles[index]=particle=new Particle(texture);
    particle.flip(flipX,flipY);
  }
  float percent=durationTimer / (float)duration;
  float offsetTime=lifeOffset + lifeOffsetDiff * lifeOffsetValue.getScale(percent);
  particle.life=particle.currentLife=life + lifeDiff * lifeValue.getScale(percent);
  if (velocityValue.active) {
    particle.velocity=velocityValue.newLowValue();
    particle.velocityDiff=velocityValue.newHighValue();
    if (!velocityValue.isRelative())     particle.velocityDiff-=particle.velocity;
  }
  particle.angle=angleValue.newLowValue();
  particle.angleDiff=angleValue.newHighValue();
  if (!angleValue.isRelative())   particle.angleDiff-=particle.angle;
  particle.size=sizeValue.newLowValue() / texture.getWidth();
  particle.sizeDiff=sizeValue.newHighValue() / texture.getWidth();
  if (!sizeValue.isRelative())   particle.sizeDiff-=particle.size;
  if (rotationValue.active) {
    particle.rotation=particle.currentRotation=rotationValue.newLowValue();
    particle.rotationDiff=rotationValue.newHighValue();
    if (!rotationValue.isRelative())     particle.rotationDiff-=particle.rotation;
  }
  if (windValue.active) {
    particle.wind=windValue.newLowValue();
    particle.windDiff=windValue.newHighValue();
    if (!windValue.isRelative())     particle.windDiff-=particle.wind;
  }
  if (gravityValue.active) {
    particle.gravity=gravityValue.newLowValue();
    particle.gravityDiff=gravityValue.newHighValue();
    if (!gravityValue.isRelative())     particle.gravityDiff-=particle.gravity;
  }
  particle.transparency=transparencyValue.newLowValue();
  particle.transparencyDiff=transparencyValue.newHighValue() - particle.transparency;
  int x=this.x;
  if (xOffsetValue.active)   x+=(int)xOffsetValue.newLowValue();
  int y=this.y;
  if (yOffsetValue.active)   y+=(int)yOffsetValue.newLowValue();
switch (spawnShapeValue.shape) {
case square:
{
      int width=spawnWidth + (int)(spawnWidthDiff * spawnWidthValue.getScale(percent));
      int height=spawnHeight + (int)(spawnHeightDiff * spawnHeightValue.getScale(percent));
      x+=MathUtils.random(width) - width / 2;
      y+=MathUtils.random(height) - height / 2;
      break;
    }
case ellipse:
{
    int width=spawnWidth + (int)(spawnWidthDiff * spawnWidthValue.getScale(percent));
    int height=spawnHeight + (int)(spawnHeightDiff * spawnHeightValue.getScale(percent));
    int radiusX=width / 2;
    int radiusY=height / 2;
    if (radiusX == 0 || radiusY == 0)     break;
    float scaleY=radiusX / (float)radiusY;
    if (spawnShapeValue.edges) {
      float angle;
switch (spawnShapeValue.side) {
case top:
        angle=-MathUtils.random(179f);
      break;
case bottom:
    angle=MathUtils.random(179f);
  break;
default :
angle=MathUtils.random(360f);
break;
}
x+=MathUtils.cosDeg(angle) * radiusX;
y+=MathUtils.sinDeg(angle) * radiusX / scaleY;
}
 else {
int radius2=radiusX * radiusX;
while (true) {
int px=MathUtils.random(width) - radiusX;
int py=MathUtils.random(width) - radiusX;
if (px * px + py * py <= radius2) {
x+=px;
y+=py / scaleY;
break;
}
}
}
break;
}
case line:
{
int width=spawnWidth + (int)(spawnWidthDiff * spawnWidthValue.getScale(percent));
int height=spawnHeight + (int)(spawnHeightDiff * spawnHeightValue.getScale(percent));
if (width != 0) {
float lineX=width * MathUtils.random();
x+=lineX;
y+=lineX * (height / (float)width);
}
break;
}
}
particle.setRotation(particle.currentRotation);
particle.setBounds(x - texture.getWidth() / 2,y - texture.getHeight() / 2,texture.getWidth(),texture.getHeight());
updateParticle(index,offsetTime);
}
