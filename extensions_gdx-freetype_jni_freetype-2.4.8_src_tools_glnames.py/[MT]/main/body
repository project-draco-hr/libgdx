def main():
    'main program body'
    if (len(sys.argv) != 2):
        print (__doc__ % sys.argv[0])
        sys.exit(1)
    file = open(sys.argv[1], 'w\n')
    write = file.write
    count_sid = len(sid_standard_names)
    mac_extras = filter_glyph_names(mac_standard_names, sid_standard_names)
    mac_extras_count = len(mac_extras)
    base_list = (mac_extras + sid_standard_names)
    write('/***************************************************************************/\n')
    write('/*                                                                         */\n')
    write(('/*  %-71s*/\n' % os.path.basename(sys.argv[1])))
    write('/*                                                                         */\n')
    write('/*    PostScript glyph names.                                              */\n')
    write('/*                                                                         */\n')
    write('/*  Copyright 2005, 2008, 2011 by                                          */\n')
    write('/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */\n')
    write('/*                                                                         */\n')
    write('/*  This file is part of the FreeType project, and may only be used,       */\n')
    write('/*  modified, and distributed under the terms of the FreeType project      */\n')
    write('/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */\n')
    write('/*  this file you indicate that you have read the license and              */\n')
    write('/*  understand and accept it fully.                                        */\n')
    write('/*                                                                         */\n')
    write('/***************************************************************************/\n')
    write('\n')
    write('\n')
    write('  /* This file has been generated automatically -- do not edit! */\n')
    write('\n')
    write('\n')
    st = StringTable(base_list, 'ft_standard_glyph_names')
    st.dump(file)
    st.dump_sublist(file, 'ft_mac_names', 'FT_NUM_MAC_NAMES', mac_standard_names)
    st.dump_sublist(file, 'ft_sid_names', 'FT_NUM_SID_NAMES', sid_standard_names)
    dump_encoding(file, 't1_standard_encoding', t1_standard_encoding)
    dump_encoding(file, 't1_expert_encoding', t1_expert_encoding)
    (agl_glyphs, agl_values) = adobe_glyph_values()
    dict = StringNode('', 0)
    for g in range(len(agl_glyphs)):
        dict.add(agl_glyphs[g], eval(('0x' + agl_values[g])))
    dict = dict.optimize()
    dict_len = dict.locate(0)
    dict_array = dict.store('')
    write("  /*\n   *  This table is a compressed version of the Adobe Glyph List (AGL),\n   *  optimized for efficient searching.  It has been generated by the\n   *  `glnames.py' python script located in the `src/tools' directory.\n   *\n   *  The lookup function to get the Unicode value for a given string\n   *  is defined below the table.\n   */\n\n#ifdef FT_CONFIG_OPTION_ADOBE_GLYPH_LIST\n\n")
    dump_array(dict_array, write, 'ft_adobe_glyph_list')
    write('  /*\n   *  This function searches the compressed table efficiently.\n   */\n  static unsigned long\n  ft_get_adobe_glyph_index( const char*  name,\n                            const char*  limit )\n  {\n    int                   c = 0;\n    int                   count, min, max;\n    const unsigned char*  p = ft_adobe_glyph_list;\n\n\n    if ( name == 0 || name >= limit )\n      goto NotFound;\n\n    c     = *name++;\n    count = p[1];\n    p    += 2;\n\n    min = 0;\n    max = count;\n\n    while ( min < max )\n    {\n      int                   mid = ( min + max ) >> 1;\n      const unsigned char*  q   = p + mid * 2;\n      int                   c2;\n\n\n      q = ft_adobe_glyph_list + ( ( (int)q[0] << 8 ) | q[1] );\n\n      c2 = q[0] & 127;\n      if ( c2 == c )\n      {\n        p = q;\n        goto Found;\n      }\n      if ( c2 < c )\n        min = mid + 1;\n      else\n        max = mid;\n    }\n    goto NotFound;\n\n  Found:\n    for (;;)\n    {\n      /* assert (*p & 127) == c */\n\n      if ( name >= limit )\n      {\n        if ( (p[0] & 128) == 0 &&\n             (p[1] & 128) != 0 )\n          return (unsigned long)( ( (int)p[2] << 8 ) | p[3] );\n\n        goto NotFound;\n      }\n      c = *name++;\n      if ( p[0] & 128 )\n      {\n        p++;\n        if ( c != (p[0] & 127) )\n          goto NotFound;\n\n        continue;\n      }\n\n      p++;\n      count = p[0] & 127;\n      if ( p[0] & 128 )\n        p += 2;\n\n      p++;\n\n      for ( ; count > 0; count--, p += 2 )\n      {\n        int                   offset = ( (int)p[0] << 8 ) | p[1];\n        const unsigned char*  q      = ft_adobe_glyph_list + offset;\n\n        if ( c == ( q[0] & 127 ) )\n        {\n          p = q;\n          goto NextIter;\n        }\n      }\n      goto NotFound;\n\n    NextIter:\n      ;\n    }\n\n  NotFound:\n    return 0;\n  }\n\n#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */\n\n')
    if 0:
        write('#ifdef TEST\n\n')
        write('static const char* const  the_names[] = {\n')
        for name in agl_glyphs:
            write((('  "' + name) + '",\n'))
        write('  0\n};\n')
        write('static const unsigned long  the_values[] = {\n')
        for val in agl_values:
            write((('  0x' + val) + ',\n'))
        write('  0\n};\n')
        write('\n#include <stdlib.h>\n#include <stdio.h>\n\n  int\n  main( void )\n  {\n    int                   result = 0;\n    const char* const*    names  = the_names;\n    const unsigned long*  values = the_values;\n\n\n    for ( ; *names; names++, values++ )\n    {\n      const char*    name      = *names;\n      unsigned long  reference = *values;\n      unsigned long  value;\n\n\n      value = ft_get_adobe_glyph_index( name, name + strlen( name ) );\n      if ( value != reference )\n      {\n        result = 1;\n        fprintf( stderr, "name \'%s\' => %04x instead of %04x\\n",\n                         name, value, reference );\n      }\n    }\n\n    return result;\n  }\n')
        write('#endif /* TEST */\n')
    write('\n/* END */\n')
