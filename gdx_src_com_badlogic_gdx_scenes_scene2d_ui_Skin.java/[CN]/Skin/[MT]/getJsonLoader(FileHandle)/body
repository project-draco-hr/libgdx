{
  final Skin skin=this;
  final Json json=new Json(){
    public <T>T readValue(    Class<T> type,    Class elementType,    JsonValue jsonData){
      if (jsonData.isString() && !ClassReflection.isAssignableFrom(CharSequence.class,type))       return get(jsonData.asString(),type);
      return super.readValue(type,elementType,jsonData);
    }
  }
;
  json.setTypeName(null);
  json.setUsePrototypes(false);
  json.setSerializer(Skin.class,new ReadOnlySerializer<Skin>(){
    public Skin read(    Json json,    JsonValue typeToValueMap,    Class ignored){
      for (JsonValue valueMap=typeToValueMap.child(); valueMap != null; valueMap=valueMap.next()) {
        try {
          readNamedObjects(json,ClassReflection.forName(valueMap.name()),valueMap);
        }
 catch (        ReflectionException ex) {
          throw new SerializationException(ex);
        }
      }
      return skin;
    }
    private void readNamedObjects(    Json json,    Class type,    JsonValue valueMap){
      Class addType=type == TintedDrawable.class ? Drawable.class : type;
      for (JsonValue valueEntry=valueMap.child(); valueEntry != null; valueEntry=valueEntry.next()) {
        Object object=json.readValue(type,valueEntry);
        if (object == null)         continue;
        try {
          add(valueEntry.name(),object,addType);
        }
 catch (        Exception ex) {
          throw new SerializationException("Error reading " + ClassReflection.getSimpleName(type) + ": "+ valueEntry.name(),ex);
        }
      }
    }
  }
);
  json.setSerializer(BitmapFont.class,new ReadOnlySerializer<BitmapFont>(){
    public BitmapFont read(    Json json,    JsonValue jsonData,    Class type){
      String path=json.readValue("file",String.class,jsonData);
      int size=json.readValue("size",int.class,-1,jsonData);
      FileHandle fontFile=skinFile.parent().child(path);
      if (!fontFile.exists())       fontFile=Gdx.files.internal(path);
      if (!fontFile.exists())       throw new SerializationException("Font file not found: " + fontFile);
      String regionName=fontFile.nameWithoutExtension();
      try {
        BitmapFont font;
        TextureRegion region=skin.optional(regionName,TextureRegion.class);
        if (region != null)         font=new BitmapFont(fontFile,region,false);
 else {
          FileHandle imageFile=fontFile.parent().child(regionName + ".png");
          if (imageFile.exists())           font=new BitmapFont(fontFile,imageFile,false);
 else           font=new BitmapFont(fontFile,false);
        }
        if (size != -1) {
          font.setScale(size / font.getData().lineHeight);
        }
        return font;
      }
 catch (      RuntimeException ex) {
        throw new SerializationException("Error loading bitmap font: " + fontFile,ex);
      }
    }
  }
);
  json.setSerializer(Color.class,new ReadOnlySerializer<Color>(){
    public Color read(    Json json,    JsonValue jsonData,    Class type){
      if (jsonData.isString())       return get(jsonData.asString(),Color.class);
      String hex=json.readValue("hex",String.class,(String)null,jsonData);
      if (hex != null)       return Color.valueOf(hex);
      float r=json.readValue("r",float.class,0f,jsonData);
      float g=json.readValue("g",float.class,0f,jsonData);
      float b=json.readValue("b",float.class,0f,jsonData);
      float a=json.readValue("a",float.class,1f,jsonData);
      return new Color(r,g,b,a);
    }
  }
);
  json.setSerializer(TintedDrawable.class,new ReadOnlySerializer(){
    public Object read(    Json json,    JsonValue jsonData,    Class type){
      String name=json.readValue("name",String.class,jsonData);
      Color color=json.readValue("color",Color.class,jsonData);
      return newDrawable(name,color);
    }
  }
);
  return json;
}
