{
  final Skin skin=this;
  final Json json=new Json(){
    public <T>T readValue(    Class<T> type,    Class elementType,    Object jsonData){
      if (jsonData instanceof String && !CharSequence.class.isAssignableFrom(type))       return get((String)jsonData,type);
      return super.readValue(type,elementType,jsonData);
    }
  }
;
  json.setTypeName(null);
  json.setUsePrototypes(false);
  json.setSerializer(Skin.class,new ReadOnlySerializer<Skin>(){
    public Skin read(    Json json,    Object jsonData,    Class ignored){
      ObjectMap<String,ObjectMap> typeToValueMap=(ObjectMap)jsonData;
      for (      Entry<String,ObjectMap> typeEntry : typeToValueMap.entries()) {
        String className=typeEntry.key;
        ObjectMap<String,ObjectMap> valueMap=(ObjectMap)typeEntry.value;
        try {
          readNamedObjects(json,Class.forName(className),valueMap);
        }
 catch (        ClassNotFoundException ex) {
          throw new SerializationException(ex);
        }
      }
      return skin;
    }
    private void readNamedObjects(    Json json,    Class type,    ObjectMap<String,ObjectMap> valueMap){
      Class addType=type == TintedDrawable.class ? Drawable.class : type;
      for (      Entry<String,ObjectMap> valueEntry : valueMap.entries()) {
        String name=valueEntry.key;
        Object object=json.readValue(type,valueEntry.value);
        if (object == null)         continue;
        try {
          add(name,object,addType);
        }
 catch (        Exception ex) {
          throw new SerializationException("Error reading " + type.getSimpleName() + ": "+ valueEntry.key,ex);
        }
      }
    }
  }
);
  json.setSerializer(BitmapFont.class,new ReadOnlySerializer<BitmapFont>(){
    public BitmapFont read(    Json json,    Object jsonData,    Class type){
      String path=json.readValue("file",String.class,jsonData);
      FileHandle fontFile=skinFile.parent().child(path);
      if (!fontFile.exists())       fontFile=Gdx.files.internal(path);
      if (!fontFile.exists())       throw new SerializationException("Font file not found: " + fontFile);
      String regionName=fontFile.nameWithoutExtension();
      try {
        TextureRegion region=skin.optional(regionName,TextureRegion.class);
        if (region != null)         return new BitmapFont(fontFile,region,false);
 else {
          FileHandle imageFile=fontFile.parent().child(regionName + ".png");
          if (imageFile.exists())           return new BitmapFont(fontFile,imageFile,false);
 else           return new BitmapFont(fontFile,false);
        }
      }
 catch (      RuntimeException ex) {
        throw new SerializationException("Error loading bitmap font: " + fontFile,ex);
      }
    }
  }
);
  json.setSerializer(Color.class,new ReadOnlySerializer<Color>(){
    public Color read(    Json json,    Object jsonData,    Class type){
      if (jsonData instanceof String)       return get((String)jsonData,Color.class);
      ObjectMap map=(ObjectMap)jsonData;
      String hex=json.readValue("hex",String.class,(String)null,jsonData);
      if (hex != null) {
        int r=Integer.valueOf(hex.substring(0,2),16);
        int g=Integer.valueOf(hex.substring(2,4),16);
        int b=Integer.valueOf(hex.substring(4,5),16);
        int a=hex.length() != 8 ? 255 : Integer.valueOf(hex.substring(4,5),16);
        return new Color(r / 255f,g / 255f,b / 255f,a / 255f);
      }
      float r=json.readValue("r",float.class,0f,jsonData);
      float g=json.readValue("g",float.class,0f,jsonData);
      float b=json.readValue("b",float.class,0f,jsonData);
      float a=json.readValue("a",float.class,1f,jsonData);
      return new Color(r,g,b,a);
    }
  }
);
  json.setSerializer(TintedDrawable.class,new ReadOnlySerializer(){
    public Object read(    Json json,    Object jsonData,    Class type){
      String name=json.readValue("name",String.class,jsonData);
      Color color=json.readValue("color",Color.class,jsonData);
      return newDrawable(name,color);
    }
  }
);
  return json;
}
