{
  ObjLoader objLoader=new ObjLoader();
  shipModel=objLoader.loadObj(Gdx.files.internal("data/ship.obj"));
  invaderModel=objLoader.loadObj(Gdx.files.internal("data/invader.obj"));
  blockModel=objLoader.loadObj(Gdx.files.internal("data/block.obj"));
  shotModel=objLoader.loadObj(Gdx.files.internal("data/shot.obj"));
  final Texture shipTexture=new Texture(Gdx.files.internal("data/ship.png"),Format.RGB565,true);
  shipTexture.setFilter(TextureFilter.MipMap,TextureFilter.Linear);
  final Texture invaderTexture=new Texture(Gdx.files.internal("data/invader.png"),Format.RGB565,true);
  invaderTexture.setFilter(TextureFilter.MipMap,TextureFilter.Linear);
  shipModel.materials.get(0).add(TextureAttribute.createDiffuse(shipTexture));
  invaderModel.materials.get(0).add(TextureAttribute.createDiffuse(invaderTexture));
  ((ColorAttribute)blockModel.materials.get(0).get(ColorAttribute.Diffuse)).color.set(0,0,1,0.5f);
  blockModel.materials.get(0).add(new BlendingAttribute(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA));
  shotModel.materials.get(0).add(ColorAttribute.createDiffuse(1,1,0,1f));
  final Texture explosionTexture=new Texture(Gdx.files.internal("data/explode.png"),Format.RGBA4444,true);
  explosionTexture.setFilter(TextureFilter.MipMap,TextureFilter.Linear);
  final Mesh explosionMesh=new Mesh(true,4 * 16,6 * 16,new VertexAttribute(Usage.Position,3,"a_position"),new VertexAttribute(Usage.TextureCoordinates,2,"a_texCoord0"));
  float[] vertices=new float[4 * 16 * (3 + 2)];
  short[] indices=new short[6 * 16];
  int idx=0;
  int index=0;
  for (int row=0; row < 4; row++) {
    for (int column=0; column < 4; column++) {
      vertices[idx++]=1;
      vertices[idx++]=1;
      vertices[idx++]=0;
      vertices[idx++]=0.25f + column * 0.25f;
      vertices[idx++]=0 + row * 0.25f;
      vertices[idx++]=-1;
      vertices[idx++]=1;
      vertices[idx++]=0;
      vertices[idx++]=0 + column * 0.25f;
      vertices[idx++]=0 + row * 0.25f;
      vertices[idx++]=-1;
      vertices[idx++]=-1;
      vertices[idx++]=0;
      vertices[idx++]=0f + column * 0.25f;
      vertices[idx++]=0.25f + row * 0.25f;
      vertices[idx++]=1;
      vertices[idx++]=-1;
      vertices[idx++]=0;
      vertices[idx++]=0.25f + column * 0.25f;
      vertices[idx++]=0.25f + row * 0.25f;
      final int t=row * column * 4;
      indices[index++]=(short)(t);
      indices[index++]=(short)(t + 1);
      indices[index++]=(short)(t + 2);
      indices[index++]=(short)(t);
      indices[index++]=(short)(t + 2);
      indices[index++]=(short)(t + 3);
    }
  }
  explosionMesh.setVertices(vertices);
  explosionMesh.setIndices(indices);
  explosionModel=ModelBuilder.createFromMesh(explosionMesh,GL10.GL_TRIANGLES,new Material(new BlendingAttribute(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA),TextureAttribute.createDiffuse(explosionTexture)));
  ship=new Ship(shipModel);
  ship.transform.rotate(0,1,0,180);
  for (int row=0; row < 4; row++) {
    for (int column=0; column < 8; column++) {
      Invader invader=new Invader(invaderModel,-PLAYFIELD_MAX_X / 2 + column * 2f,0,PLAYFIELD_MIN_Z + row * 2f);
      invaders.add(invader);
    }
  }
  for (int shield=0; shield < 3; shield++) {
    blocks.add(new Block(blockModel,-10 + shield * 10 - 1,0,-2));
    blocks.add(new Block(blockModel,-10 + shield * 10 - 1,0,-3));
    blocks.add(new Block(blockModel,-10 + shield * 10 + 0,0,-3));
    blocks.add(new Block(blockModel,-10 + shield * 10 + 1,0,-3));
    blocks.add(new Block(blockModel,-10 + shield * 10 + 1,0,-2));
  }
}
