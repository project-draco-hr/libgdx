{
  float overlap=Float.MAX_VALUE;
  float smallestAxisX=0;
  float smallestAxisY=0;
  final int numAxes1=verts1.length;
  for (int i=0; i < numAxes1; i+=2) {
    float x1=verts1[i];
    float y1=verts1[i + 1];
    float x2=verts1[(i + 2) % numAxes1];
    float y2=verts1[(i + 3) % numAxes1];
    float axisX=y1 - y2;
    float axisY=-(x1 - x2);
    final float length=(float)Math.sqrt(axisX * axisX + axisY * axisY);
    axisX/=length;
    axisY/=length;
    float min1=(axisX * verts1[0]) + (axisY * verts1[1]);
    float max1=min1;
    for (int j=2; j < verts1.length; j+=2) {
      float p=(axisX * verts1[j]) + (axisY * verts1[j + 1]);
      if (p < min1) {
        min1=p;
      }
 else       if (p > max1) {
        max1=p;
      }
    }
    float min2=(axisX * verts2[0]) + (axisY * verts2[1]);
    float max2=min2;
    for (int j=2; j < verts2.length; j+=2) {
      float p=(axisX * verts2[j]) + (axisY * verts2[j + 1]);
      if (p < min2) {
        min2=p;
      }
 else       if (p > max2) {
        max2=p;
      }
    }
    if (!((min1 < min2 && max1 > min2) || (min2 < min1 && max2 > min1))) {
      return false;
    }
 else {
      float o=Math.min(max1,max2) - Math.max(min1,min2);
      if ((min1 < min2 && max1 > max2) || (min2 < min1 && max2 > max1)) {
        float mins=Math.abs(min1 - min2);
        float maxs=Math.abs(max1 - max2);
        if (mins < maxs) {
          axisX=-axisX;
          axisY=-axisY;
          o+=mins;
        }
 else {
          o+=maxs;
        }
      }
      if (o < overlap) {
        overlap=o;
        smallestAxisX=axisX;
        smallestAxisY=axisY;
      }
    }
  }
  final int numAxes2=verts2.length;
  for (int i=0; i < numAxes2; i+=2) {
    float x1=verts2[i];
    float y1=verts2[i + 1];
    float x2=verts2[(i + 2) % numAxes2];
    float y2=verts2[(i + 3) % numAxes2];
    float axisX=y1 - y2;
    float axisY=-(x1 - x2);
    final float length=(float)Math.sqrt(axisX * axisX + axisY * axisY);
    axisX/=length;
    axisY/=length;
    float min1=(axisX * verts1[0]) + (axisY * verts1[1]);
    float max1=min1;
    for (int j=2; j < verts1.length; j+=2) {
      float p=(axisX * verts1[j]) + (axisY * verts1[j + 1]);
      if (p < min1) {
        min1=p;
      }
 else       if (p > max1) {
        max1=p;
      }
    }
    float min2=(axisX * verts2[0]) + (axisY * verts2[1]);
    float max2=min2;
    for (int j=2; j < verts2.length; j+=2) {
      float p=(axisX * verts2[j]) + (axisY * verts2[j + 1]);
      if (p < min2) {
        min2=p;
      }
 else       if (p > max2) {
        max2=p;
      }
    }
    if (!((min1 < min2 && max1 > min2) || (min2 < min1 && max2 > min1))) {
      return false;
    }
 else {
      float o=Math.min(max1,max2) - Math.max(min1,min2);
      if ((min1 < min2 && max1 > max2) || (min2 < min1 && max2 > max1)) {
        float mins=Math.abs(min1 - min2);
        float maxs=Math.abs(max1 - max2);
        if (mins < maxs) {
          axisX=-axisX;
          axisY=-axisY;
          o+=mins;
        }
 else {
          o+=maxs;
        }
      }
      if (o < overlap) {
        overlap=o;
        smallestAxisX=axisX;
        smallestAxisY=axisY;
      }
    }
  }
  if (mtv != null) {
    mtv.normal.set(smallestAxisX,smallestAxisY);
    mtv.depth=overlap;
  }
  return true;
}
