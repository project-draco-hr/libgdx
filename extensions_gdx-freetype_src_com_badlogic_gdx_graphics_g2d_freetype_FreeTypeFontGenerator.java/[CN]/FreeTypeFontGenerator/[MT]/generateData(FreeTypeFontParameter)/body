{
  parameter=parameter == null ? new FreeTypeFontParameter() : parameter;
  FreeTypeBitmapFontData data=new FreeTypeBitmapFontData();
  if (!bitmapped && !face.setPixelSizes(0,parameter.size))   throw new GdxRuntimeException("Couldn't set size for font");
  SizeMetrics fontMetrics=face.getSize().getMetrics();
  data.flipped=parameter.flip;
  data.ascent=FreeType.toInt(fontMetrics.getAscender());
  data.descent=FreeType.toInt(fontMetrics.getDescender());
  data.lineHeight=FreeType.toInt(fontMetrics.getHeight());
  float baseLine=data.ascent;
  if (bitmapped && (data.lineHeight == 0)) {
    for (int c=32; c < (32 + face.getNumGlyphs()); c++) {
      if (face.loadChar(c,FreeType.FT_LOAD_DEFAULT)) {
        int lh=FreeType.toInt(face.getGlyph().getMetrics().getHeight());
        data.lineHeight=(lh > data.lineHeight) ? lh : data.lineHeight;
      }
    }
  }
  if (face.loadChar(' ',FreeType.FT_LOAD_DEFAULT)) {
    data.spaceWidth=FreeType.toInt(face.getGlyph().getMetrics().getHoriAdvance());
  }
 else {
    data.spaceWidth=face.getMaxAdvanceWidth();
  }
  Glyph spaceGlyph=new Glyph();
  spaceGlyph.xadvance=(int)data.spaceWidth;
  spaceGlyph.id=(int)' ';
  data.setGlyph(' ',spaceGlyph);
  for (  char xChar : BitmapFont.xChars) {
    if (!face.loadChar(xChar,FreeType.FT_LOAD_DEFAULT))     continue;
    data.xHeight=FreeType.toInt(face.getGlyph().getMetrics().getHeight());
    break;
  }
  if (data.xHeight == 0)   throw new GdxRuntimeException("No x-height character found in font");
  for (  char capChar : BitmapFont.capChars) {
    if (!face.loadChar(capChar,FreeType.FT_LOAD_DEFAULT))     continue;
    data.capHeight=FreeType.toInt(face.getGlyph().getMetrics().getHeight());
    break;
  }
  if (!bitmapped && data.capHeight == 1)   throw new GdxRuntimeException("No cap character found in font");
  data.ascent=data.ascent - data.capHeight;
  data.down=-data.lineHeight;
  if (parameter.flip) {
    data.ascent=-data.ascent;
    data.down=-data.down;
  }
  boolean ownsAtlas=false;
  PixmapPacker packer=parameter.packer;
  if (packer == null) {
    int maxGlyphHeight=(int)Math.ceil(data.lineHeight);
    int pageWidth=MathUtils.nextPowerOfTwo((int)Math.sqrt(maxGlyphHeight * maxGlyphHeight * parameter.characters.length()));
    if (maxTextureSize > 0)     pageWidth=Math.min(pageWidth,maxTextureSize);
    ownsAtlas=true;
    packer=new PixmapPacker(pageWidth,pageWidth,Format.RGBA8888,2,false);
  }
  String packPrefix=ownsAtlas ? "" : (filePath + '_' + parameter.size+ (parameter.flip ? "_flip_" : '_'));
  Stroker stroker=null;
  if (parameter.borderWidth > 0) {
    stroker=library.createStroker();
    stroker.set((int)(parameter.borderWidth * 64f),parameter.borderStraight ? FreeType.FT_STROKER_LINECAP_BUTT : FreeType.FT_STROKER_LINECAP_ROUND,parameter.borderStraight ? FreeType.FT_STROKER_LINEJOIN_MITER_FIXED : FreeType.FT_STROKER_LINEJOIN_ROUND,0);
  }
  for (int i=0; i < parameter.characters.length(); i++) {
    char c=parameter.characters.charAt(i);
    if (!face.loadChar(c,FreeType.FT_LOAD_DEFAULT)) {
      Gdx.app.log("FreeTypeFontGenerator","Couldn't load char '" + c + "'");
      continue;
    }
    GlyphSlot slot=face.getGlyph();
    com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph mainGlyph=slot.getGlyph();
    try {
      mainGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
    }
 catch (    GdxRuntimeException e) {
      mainGlyph.dispose();
      Gdx.app.log("FreeTypeFontGenerator","Couldn't render char '" + c + "'");
      continue;
    }
    Bitmap mainBitmap=mainGlyph.getBitmap();
    Pixmap mainPixmap=mainBitmap.getPixmap(Format.RGBA8888,parameter.color);
    if (parameter.borderWidth > 0 || parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
      com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph borderGlyph=mainGlyph;
      Bitmap borderBitmap=mainBitmap;
      if (parameter.borderWidth > 0) {
        borderGlyph=slot.getGlyph();
        borderGlyph.strokeBorder(stroker,false);
        borderGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
        borderBitmap=borderGlyph.getBitmap();
        Pixmap borderPixmap=borderBitmap.getPixmap(Format.RGBA8888,parameter.borderColor);
        borderPixmap.drawPixmap(mainPixmap,mainGlyph.getLeft() - borderGlyph.getLeft(),-(mainGlyph.getTop() - borderGlyph.getTop()));
        mainPixmap.dispose();
        mainGlyph.dispose();
        mainPixmap=borderPixmap;
        mainGlyph=borderGlyph;
      }
      if (parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
        Pixmap shadowPixmapSrc=borderBitmap.getPixmap(Format.RGBA8888,parameter.shadowColor);
        Pixmap shadowPixmap=new Pixmap(shadowPixmapSrc.getWidth() + Math.abs(parameter.shadowOffsetX),shadowPixmapSrc.getHeight() + Math.abs(parameter.shadowOffsetY),Format.RGBA8888);
        Blending blending=Pixmap.getBlending();
        Pixmap.setBlending(Blending.None);
        shadowPixmap.drawPixmap(shadowPixmapSrc,Math.max(parameter.shadowOffsetX,0),Math.max(parameter.shadowOffsetY,0));
        Pixmap.setBlending(blending);
        shadowPixmap.drawPixmap(mainPixmap,Math.max(-parameter.shadowOffsetX,0),Math.max(-parameter.shadowOffsetY,0));
        mainPixmap.dispose();
        mainPixmap=shadowPixmap;
      }
    }
    GlyphMetrics metrics=slot.getMetrics();
    Glyph glyph=new Glyph();
    glyph.id=c;
    glyph.width=mainPixmap.getWidth();
    glyph.height=mainPixmap.getHeight();
    glyph.xoffset=mainGlyph.getLeft();
    glyph.yoffset=parameter.flip ? -mainGlyph.getTop() + (int)baseLine : -(glyph.height - mainGlyph.getTop()) - (int)baseLine;
    glyph.xadvance=FreeType.toInt(metrics.getHoriAdvance()) + (int)parameter.borderWidth;
    if (bitmapped) {
      mainPixmap.setColor(Color.CLEAR);
      mainPixmap.fill();
      ByteBuffer buf=mainBitmap.getBuffer();
      for (int h=0; h < glyph.height; h++) {
        int idx=h * mainBitmap.getPitch();
        for (int w=0; w < (glyph.width + glyph.xoffset); w++) {
          int bit=(buf.get(idx + (w / 8)) >>> (7 - (w % 8))) & 1;
          mainPixmap.drawPixel(w,h,((bit == 1) ? Color.WHITE.toIntBits() : Color.CLEAR.toIntBits()));
        }
      }
    }
    String name=packPrefix + c;
    Rectangle rect=packer.pack(name,mainPixmap);
    int pIndex=packer.getPageIndex(name);
    if (pIndex == -1)     throw new IllegalStateException("packer was not able to insert '" + name + "' into a page");
    glyph.page=pIndex;
    glyph.srcX=(int)rect.x;
    glyph.srcY=(int)rect.y;
    data.setGlyph(c,glyph);
    mainPixmap.dispose();
    mainGlyph.dispose();
  }
  if (stroker != null) {
    stroker.dispose();
  }
  if (parameter.kerning) {
    for (int i=0; i < parameter.characters.length(); i++) {
      for (int j=0; j < parameter.characters.length(); j++) {
        char firstChar=parameter.characters.charAt(i);
        Glyph first=data.getGlyph(firstChar);
        if (first == null)         continue;
        char secondChar=parameter.characters.charAt(j);
        Glyph second=data.getGlyph(secondChar);
        if (second == null)         continue;
        int kerning=face.getKerning(face.getCharIndex(firstChar),face.getCharIndex(secondChar),0);
        if (kerning == 0)         continue;
        first.setKerning(secondChar,FreeType.toInt(kerning));
      }
    }
  }
  if (ownsAtlas) {
    Array<Page> pages=packer.getPages();
    data.regions=new TextureRegion[pages.size];
    for (int i=0; i < pages.size; i++) {
      Page p=pages.get(i);
      Texture tex=new Texture(new PixmapTextureData(p.getPixmap(),p.getPixmap().getFormat(),parameter.genMipMaps,false,true)){
        @Override public void dispose(){
          super.dispose();
          getTextureData().consumePixmap().dispose();
        }
      }
;
      tex.setFilter(parameter.minFilter,parameter.magFilter);
      data.regions[i]=new TextureRegion(tex);
    }
  }
  return data;
}
