{
  if (pVertexTypes[pEarTipIndex] != CONVEX_OR_TANGENTIAL) {
    return false;
  }
  if (this.concaveVertexCount == 0) {
    return true;
  }
  final int previousIndex=computePreviousIndex(pVertices,pEarTipIndex);
  final int nextIndex=computeNextIndex(pVertices,pEarTipIndex);
  final Vector2 p1=pVertices.get(previousIndex);
  final Vector2 p2=pVertices.get(pEarTipIndex);
  final Vector2 p3=pVertices.get(nextIndex);
  final int vertexCount=pVertices.size();
  for (int i=computeNextIndex(pVertices,nextIndex); i != previousIndex; i=computeNextIndex(pVertices,i)) {
    if ((pVertexTypes[i] == CONCAVE)) {
      final Vector2 v=pVertices.get(i);
      final int areaSign1=computeSpannedAreaSign(p1,p2,v);
      final int areaSign2=computeSpannedAreaSign(p2,p3,v);
      final int areaSign3=computeSpannedAreaSign(p3,p1,v);
      if (!((areaSign1 > 0 || areaSign2 > 0 || areaSign3 > 0) && (areaSign1 < 0 || areaSign2 < 0 || areaSign3 < 0))) {
        return false;
      }
    }
  }
  return true;
}
