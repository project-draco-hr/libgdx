{
  p("Map<String, Type> types = new HashMap<String, Type>();");
  TypeOracle typeOracle=context.getTypeOracle();
  JPackage[] packages=typeOracle.getPackages();
  for (  JPackage p : packages) {
    for (    JClassType t : p.getTypes()) {
      gatherTypes(t.getErasedType(),types);
    }
  }
  gatherTypes(typeOracle.findType("java.util.List").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.util.ArrayList").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.util.HashMap").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.util.Map").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.String").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Boolean").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Byte").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Long").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Character").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Short").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Integer").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Float").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.CharSequence").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Double").getErasedType(),types);
  gatherTypes(typeOracle.findType("java.lang.Object").getErasedType(),types);
  Collections.sort(types,new Comparator<JType>(){
    public int compare(    JType o1,    JType o2){
      return o1.getQualifiedSourceName().compareTo(o2.getQualifiedSourceName());
    }
  }
);
  int id=0;
  for (  JType t : types) {
    String typeGen=createTypeGenerator(t);
    p("private void c" + (id++) + "() {");
    p(typeGen);
    p("}\n");
  }
  p("public " + simpleName + "() {");
  for (int i=0; i < id; i++) {
    p("c" + i + "();");
  }
  p("}");
  Collections.sort(setterGetterStubs,new Comparator<SetterGetterStub>(){
    @Override public int compare(    SetterGetterStub o1,    SetterGetterStub o2){
      return new Integer(o1.setter).compareTo(o2.setter);
    }
  }
);
  for (  SetterGetterStub stub : setterGetterStubs) {
    String stubSource=generateSetterGetterStub(stub);
    if (stubSource.equals(""))     stub.unused=true;
    p(stubSource);
  }
  Collections.sort(methodStubs,new Comparator<MethodStub>(){
    @Override public int compare(    MethodStub o1,    MethodStub o2){
      return new Integer(o1.methodId).compareTo(o2.methodId);
    }
  }
);
  for (  MethodStub stub : methodStubs) {
    String stubSource=generateMethodStub(stub);
    if (stubSource.equals(""))     stub.unused=true;
    p(stubSource);
  }
  logger.log(Type.INFO,types.size() + " types reflected");
}
