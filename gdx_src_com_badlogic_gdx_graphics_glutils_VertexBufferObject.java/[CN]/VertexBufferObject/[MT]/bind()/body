{
  GL11 gl=Gdx.gl11;
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,bufferHandle);
  if (isDirty) {
    byteBuffer.limit(buffer.limit() * 4);
    gl.glBufferData(GL11.GL_ARRAY_BUFFER,byteBuffer.limit(),byteBuffer,usage);
    isDirty=false;
  }
  int textureUnit=0;
  int numAttributes=attributes.size();
  for (int i=0; i < numAttributes; i++) {
    VertexAttribute attribute=attributes.get(i);
switch (attribute.usage) {
case Usage.Position:
      gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
    gl.glVertexPointer(attribute.numComponents,GL10.GL_FLOAT,attributes.vertexSize,attribute.offset);
  break;
case Usage.Color:
case Usage.ColorPacked:
int colorType=GL10.GL_FLOAT;
if (attribute.usage == Usage.ColorPacked) colorType=GL11.GL_UNSIGNED_BYTE;
gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
gl.glColorPointer(attribute.numComponents,colorType,attributes.vertexSize,attribute.offset);
break;
case Usage.Normal:
gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
gl.glNormalPointer(GL10.GL_FLOAT,attributes.vertexSize,attribute.offset);
break;
case Usage.TextureCoordinates:
gl.glClientActiveTexture(GL10.GL_TEXTURE0 + textureUnit);
gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
gl.glTexCoordPointer(attribute.numComponents,GL10.GL_FLOAT,attributes.vertexSize,attribute.offset);
textureUnit++;
break;
default :
}
}
isBound=true;
}
