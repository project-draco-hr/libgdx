{
  float minSeparation=0.0f;
  for (int i=0; i < m_count; ++i) {
    ContactPositionConstraint pc=m_positionConstraints[i];
    int indexA=pc.indexA;
    int indexB=pc.indexB;
    float mA=pc.invMassA;
    float iA=pc.invIA;
    Vec2 localCenterA=pc.localCenterA;
    float mB=pc.invMassB;
    float iB=pc.invIB;
    Vec2 localCenterB=pc.localCenterB;
    int pointCount=pc.pointCount;
    Vec2 cA=m_positions[indexA].c;
    float aA=m_positions[indexA].a;
    Vec2 cB=m_positions[indexB].c;
    float aB=m_positions[indexB].a;
    for (int j=0; j < pointCount; ++j) {
      xfA.q.set(aA);
      xfB.q.set(aB);
      Rot.mulToOutUnsafe(xfA.q,localCenterA,xfA.p);
      xfA.p.negateLocal().addLocal(cA);
      Rot.mulToOutUnsafe(xfB.q,localCenterB,xfB.p);
      xfB.p.negateLocal().addLocal(cB);
      final PositionSolverManifold psm=psolver;
      psm.initialize(pc,xfA,xfB,j);
      final Vec2 normal=psm.normal;
      final Vec2 point=psm.point;
      final float separation=psm.separation;
      rA.set(point).subLocal(cA);
      rB.set(point).subLocal(cB);
      minSeparation=MathUtils.min(minSeparation,separation);
      final float C=MathUtils.clamp(Settings.baumgarte * (separation + Settings.linearSlop),-Settings.maxLinearCorrection,0.0f);
      final float rnA=Vec2.cross(rA,normal);
      final float rnB=Vec2.cross(rB,normal);
      final float K=mA + mB + iA * rnA * rnA + iB * rnB * rnB;
      final float impulse=K > 0.0f ? -C / K : 0.0f;
      P.set(normal).mulLocal(impulse);
      cA.subLocal(temp.set(P).mulLocal(mA));
      aA-=iA * Vec2.cross(rA,P);
      cB.addLocal(temp.set(P).mulLocal(mB));
      aB+=iB * Vec2.cross(rB,P);
    }
    m_positions[indexA].c.set(cA);
    m_positions[indexA].a=aA;
    m_positions[indexB].c.set(cB);
    m_positions[indexB].a=aB;
  }
  return minSeparation >= -3.0f * Settings.linearSlop;
}
