{
  final int count1=poly1.m_count;
  final Vec2[] vertices1=poly1.m_vertices;
  final Vec2[] normals1=poly1.m_normals;
  final int count2=poly2.m_count;
  final Vec2[] vertices2=poly2.m_vertices;
  assert(0 <= edge1 && edge1 < count1);
  final Rot xf1q=xf1.q;
  final Rot xf2q=xf2.q;
  Rot q=xf1q;
  Vec2 v=normals1[edge1];
  final float normal1Worldx=q.c * v.x - q.s * v.y;
  final float normal1Worldy=q.s * v.x + q.c * v.y;
  Rot q1=xf2q;
  final float normal1x=q1.c * normal1Worldx + q1.s * normal1Worldy;
  final float normal1y=-q1.s * normal1Worldx + q1.c * normal1Worldy;
  int index=0;
  float minDot=Float.MAX_VALUE;
  for (int i=0; i < count2; ++i) {
    final Vec2 a=vertices2[i];
    final float dot=a.x * normal1x + a.y * normal1y;
    if (dot < minDot) {
      minDot=dot;
      index=i;
    }
  }
  Vec2 v3=vertices1[edge1];
  final float v1x=(xf1q.c * v3.x - xf1q.s * v3.y) + xf1.p.x;
  final float v1y=(xf1q.s * v3.x + xf1q.c * v3.y) + xf1.p.y;
  Vec2 v4=vertices2[index];
  final float v2x=(xf2q.c * v4.x - xf2q.s * v4.y) + xf2.p.x - v1x;
  final float v2y=(xf2q.s * v4.x + xf2q.c * v4.y) + xf2.p.y - v1y;
  float separation=v2x * normal1Worldx + v2y * normal1Worldy;
  return separation;
}
