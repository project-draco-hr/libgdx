{
  Transform.mulTransToOutUnsafe(xfA,xfB,m_xf);
  Transform.mulToOutUnsafe(m_xf,polygonB.m_centroid,m_centroidB);
  m_v0=edgeA.m_vertex0;
  m_v1=edgeA.m_vertex1;
  m_v2=edgeA.m_vertex2;
  m_v3=edgeA.m_vertex3;
  boolean hasVertex0=edgeA.m_hasVertex0;
  boolean hasVertex3=edgeA.m_hasVertex3;
  edge1.set(m_v2).subLocal(m_v1);
  edge1.normalize();
  m_normal1.set(edge1.y,-edge1.x);
  float offset1=Vec2.dot(m_normal1,temp.set(m_centroidB).subLocal(m_v1));
  float offset0=0.0f, offset2=0.0f;
  boolean convex1=false, convex2=false;
  if (hasVertex0) {
    edge0.set(m_v1).subLocal(m_v0);
    edge0.normalize();
    m_normal0.set(edge0.y,-edge0.x);
    convex1=Vec2.cross(edge0,edge1) >= 0.0f;
    offset0=Vec2.dot(m_normal0,temp.set(m_centroidB).subLocal(m_v0));
  }
  if (hasVertex3) {
    edge2.set(m_v3).subLocal(m_v2);
    edge2.normalize();
    m_normal2.set(edge2.y,-edge2.x);
    convex2=Vec2.cross(edge1,edge2) > 0.0f;
    offset2=Vec2.dot(m_normal2,temp.set(m_centroidB).subLocal(m_v2));
  }
  if (hasVertex0 && hasVertex3) {
    if (convex1 && convex2) {
      m_front=offset0 >= 0.0f || offset1 >= 0.0f || offset2 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal0);
        m_upperLimit.set(m_normal2);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal1).negateLocal();
        m_upperLimit.set(m_normal1).negateLocal();
      }
    }
 else     if (convex1) {
      m_front=offset0 >= 0.0f || (offset1 >= 0.0f && offset2 >= 0.0f);
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal0);
        m_upperLimit.set(m_normal1);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal2).negateLocal();
        m_upperLimit.set(m_normal1).negateLocal();
      }
    }
 else     if (convex2) {
      m_front=offset2 >= 0.0f || (offset0 >= 0.0f && offset1 >= 0.0f);
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal1);
        m_upperLimit.set(m_normal2);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal1).negateLocal();
        m_upperLimit.set(m_normal0).negateLocal();
      }
    }
 else {
      m_front=offset0 >= 0.0f && offset1 >= 0.0f && offset2 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal1);
        m_upperLimit.set(m_normal1);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal2).negateLocal();
        m_upperLimit.set(m_normal0).negateLocal();
      }
    }
  }
 else   if (hasVertex0) {
    if (convex1) {
      m_front=offset0 >= 0.0f || offset1 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal0);
        m_upperLimit.set(m_normal1).negateLocal();
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal1);
        m_upperLimit.set(m_normal1).negateLocal();
      }
    }
 else {
      m_front=offset0 >= 0.0f && offset1 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal1);
        m_upperLimit.set(m_normal1).negateLocal();
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal1);
        m_upperLimit.set(m_normal0).negateLocal();
      }
    }
  }
 else   if (hasVertex3) {
    if (convex2) {
      m_front=offset1 >= 0.0f || offset2 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal1).negateLocal();
        m_upperLimit.set(m_normal2);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal1).negateLocal();
        m_upperLimit.set(m_normal1);
      }
    }
 else {
      m_front=offset1 >= 0.0f && offset2 >= 0.0f;
      if (m_front) {
        m_normal.set(m_normal1);
        m_lowerLimit.set(m_normal1).negateLocal();
        m_upperLimit.set(m_normal1);
      }
 else {
        m_normal.set(m_normal1).negateLocal();
        m_lowerLimit.set(m_normal2).negateLocal();
        m_upperLimit.set(m_normal1);
      }
    }
  }
 else {
    m_front=offset1 >= 0.0f;
    if (m_front) {
      m_normal.set(m_normal1);
      m_lowerLimit.set(m_normal1).negateLocal();
      m_upperLimit.set(m_normal1).negateLocal();
    }
 else {
      m_normal.set(m_normal1).negateLocal();
      m_lowerLimit.set(m_normal1);
      m_upperLimit.set(m_normal1);
    }
  }
  m_polygonB.count=polygonB.m_count;
  for (int i=0; i < polygonB.m_count; ++i) {
    Transform.mulToOutUnsafe(m_xf,polygonB.m_vertices[i],m_polygonB.vertices[i]);
    Rot.mulToOutUnsafe(m_xf.q,polygonB.m_normals[i],m_polygonB.normals[i]);
  }
  m_radius=2.0f * Settings.polygonRadius;
  manifold.pointCount=0;
  computeEdgeSeparation(edgeAxis);
  if (edgeAxis.type == EPAxis.Type.UNKNOWN) {
    return;
  }
  if (edgeAxis.separation > m_radius) {
    return;
  }
  computePolygonSeparation(polygonAxis);
  if (polygonAxis.type != EPAxis.Type.UNKNOWN && polygonAxis.separation > m_radius) {
    return;
  }
  final float k_relativeTol=0.98f;
  final float k_absoluteTol=0.001f;
  EPAxis primaryAxis;
  if (polygonAxis.type == EPAxis.Type.UNKNOWN) {
    primaryAxis=edgeAxis;
  }
 else   if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
    primaryAxis=polygonAxis;
  }
 else {
    primaryAxis=edgeAxis;
  }
  if (primaryAxis.type == EPAxis.Type.EDGE_A) {
    manifold.type=Manifold.ManifoldType.FACE_A;
    int bestIndex=0;
    float bestValue=Vec2.dot(m_normal,m_polygonB.normals[0]);
    for (int i=1; i < m_polygonB.count; ++i) {
      float value=Vec2.dot(m_normal,m_polygonB.normals[i]);
      if (value < bestValue) {
        bestValue=value;
        bestIndex=i;
      }
    }
    int i1=bestIndex;
    int i2=i1 + 1 < m_polygonB.count ? i1 + 1 : 0;
    ie[0].v.set(m_polygonB.vertices[i1]);
    ie[0].id.indexA=0;
    ie[0].id.indexB=(byte)i1;
    ie[0].id.typeA=(byte)ContactID.Type.FACE.ordinal();
    ie[0].id.typeB=(byte)ContactID.Type.VERTEX.ordinal();
    ie[1].v.set(m_polygonB.vertices[i2]);
    ie[1].id.indexA=0;
    ie[1].id.indexB=(byte)i2;
    ie[1].id.typeA=(byte)ContactID.Type.FACE.ordinal();
    ie[1].id.typeB=(byte)ContactID.Type.VERTEX.ordinal();
    if (m_front) {
      rf.i1=0;
      rf.i2=1;
      rf.v1.set(m_v1);
      rf.v2.set(m_v2);
      rf.normal.set(m_normal1);
    }
 else {
      rf.i1=1;
      rf.i2=0;
      rf.v1.set(m_v2);
      rf.v2.set(m_v1);
      rf.normal.set(m_normal1).negateLocal();
    }
  }
 else {
    manifold.type=Manifold.ManifoldType.FACE_B;
    ie[0].v.set(m_v1);
    ie[0].id.indexA=0;
    ie[0].id.indexB=(byte)primaryAxis.index;
    ie[0].id.typeA=(byte)ContactID.Type.VERTEX.ordinal();
    ie[0].id.typeB=(byte)ContactID.Type.FACE.ordinal();
    ie[1].v.set(m_v2);
    ie[1].id.indexA=0;
    ie[1].id.indexB=(byte)primaryAxis.index;
    ie[1].id.typeA=(byte)ContactID.Type.VERTEX.ordinal();
    ie[1].id.typeB=(byte)ContactID.Type.FACE.ordinal();
    rf.i1=primaryAxis.index;
    rf.i2=rf.i1 + 1 < m_polygonB.count ? rf.i1 + 1 : 0;
    rf.v1.set(m_polygonB.vertices[rf.i1]);
    rf.v2.set(m_polygonB.vertices[rf.i2]);
    rf.normal.set(m_polygonB.normals[rf.i1]);
  }
  rf.sideNormal1.set(rf.normal.y,-rf.normal.x);
  rf.sideNormal2.set(rf.sideNormal1).negateLocal();
  rf.sideOffset1=Vec2.dot(rf.sideNormal1,rf.v1);
  rf.sideOffset2=Vec2.dot(rf.sideNormal2,rf.v2);
  int np;
  np=clipSegmentToLine(clipPoints1,ie,rf.sideNormal1,rf.sideOffset1,rf.i1);
  if (np < Settings.maxManifoldPoints) {
    return;
  }
  np=clipSegmentToLine(clipPoints2,clipPoints1,rf.sideNormal2,rf.sideOffset2,rf.i2);
  if (np < Settings.maxManifoldPoints) {
    return;
  }
  if (primaryAxis.type == EPAxis.Type.EDGE_A) {
    manifold.localNormal.set(rf.normal);
    manifold.localPoint.set(rf.v1);
  }
 else {
    manifold.localNormal.set(polygonB.m_normals[rf.i1]);
    manifold.localPoint.set(polygonB.m_vertices[rf.i1]);
  }
  int pointCount=0;
  for (int i=0; i < Settings.maxManifoldPoints; ++i) {
    float separation;
    separation=Vec2.dot(rf.normal,temp.set(clipPoints2[i].v).subLocal(rf.v1));
    if (separation <= m_radius) {
      ManifoldPoint cp=manifold.points[pointCount];
      if (primaryAxis.type == EPAxis.Type.EDGE_A) {
        Transform.mulTransToOutUnsafe(m_xf,clipPoints2[i].v,cp.localPoint);
        cp.id.set(clipPoints2[i].id);
      }
 else {
        cp.localPoint.set(clipPoints2[i].v);
        cp.id.typeA=clipPoints2[i].id.typeB;
        cp.id.typeB=clipPoints2[i].id.typeA;
        cp.id.indexA=clipPoints2[i].id.indexB;
        cp.id.indexB=clipPoints2[i].id.indexA;
      }
      ++pointCount;
    }
  }
  manifold.pointCount=pointCount;
}
