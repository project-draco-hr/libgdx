{
  BufferedReader reader=new BufferedReader(new InputStreamReader(in),1024);
  MD5Model model=new MD5Model();
  List<String> tokens=new ArrayList<String>(10);
  MD5Quaternion quat=new MD5Quaternion();
  int floatsPerVert=4;
  if (allocateNormals)   floatsPerVert+=3;
  int floatsPerWeight=5;
  if (allocateNormals)   floatsPerWeight+=3;
  try {
    String line;
    int currMesh=0;
    while ((line=reader.readLine()) != null) {
      MD5Tokenizer.tokenize(line,tokens);
      if (tokens.size() == 0)       continue;
      if (tokens.get(0).equals("MD5Version")) {
        int version=parseInt(tokens.get(1));
        if (version != 10)         throw new IllegalArgumentException("Not a valid MD5 file, go version " + version + ", need 10");
      }
      if (tokens.get(0).equals("numJoints")) {
        int numJoints=parseInt(tokens.get(1));
        model.baseSkeleton=new MD5Joints();
        model.baseSkeleton.names=new String[numJoints];
        model.baseSkeleton.numJoints=numJoints;
        model.baseSkeleton.joints=new float[numJoints * 8];
      }
      if (tokens.get(0).equals("numMeshes")) {
        int numMeshes=parseInt(tokens.get(1));
        model.meshes=new MD5Mesh[numMeshes];
      }
      if (tokens.get(0).equals("joints")) {
        for (int i=0; i < model.baseSkeleton.numJoints; i++) {
          line=reader.readLine();
          MD5Tokenizer.tokenize(line,tokens);
          if (tokens.size() == 0) {
            i--;
            continue;
          }
          int jointIdx=i << 3;
          model.baseSkeleton.names[i]=tokens.get(0);
          ;
          model.baseSkeleton.joints[jointIdx]=parseInt(tokens.get(1));
          ;
          model.baseSkeleton.joints[jointIdx + 1]=parseFloat(tokens.get(3));
          model.baseSkeleton.joints[jointIdx + 2]=parseFloat(tokens.get(4));
          model.baseSkeleton.joints[jointIdx + 3]=parseFloat(tokens.get(5));
          quat.x=parseFloat(tokens.get(8));
          quat.y=parseFloat(tokens.get(9));
          quat.z=parseFloat(tokens.get(10));
          quat.computeW();
          model.baseSkeleton.joints[jointIdx + 4]=quat.x;
          model.baseSkeleton.joints[jointIdx + 5]=quat.y;
          model.baseSkeleton.joints[jointIdx + 6]=quat.z;
          model.baseSkeleton.joints[jointIdx + 7]=quat.w;
        }
      }
      if (tokens.get(0).equals("mesh") && tokens.get(1).equals("{")) {
        MD5Mesh mesh=new MD5Mesh();
        mesh.floatsPerVertex=floatsPerVert;
        mesh.floatsPerWeight=floatsPerWeight;
        model.meshes[currMesh++]=mesh;
        int vertIndex=0;
        int triIndex=0;
        int weightIndex=0;
        while (!line.contains("}")) {
          line=reader.readLine();
          MD5Tokenizer.tokenize(line,tokens);
          if (tokens.size() == 0)           continue;
          if (tokens.get(0).equals("shader")) {
            mesh.shader=tokens.get(1);
          }
          if (tokens.get(0).equals("numverts")) {
            mesh.numVertices=parseInt(tokens.get(1));
            mesh.vertices=new float[mesh.numVertices * floatsPerVert];
          }
          if (tokens.get(0).equals("numtris")) {
            mesh.indices=new short[parseInt(tokens.get(1)) * 3];
            mesh.numTriangles=mesh.indices.length / 3;
          }
          if (tokens.get(0).equals("numweights")) {
            mesh.numWeights=parseInt(tokens.get(1));
            mesh.weights=new float[mesh.numWeights * floatsPerWeight];
          }
          if (tokens.get(0).equals("vert")) {
            vertIndex=parseInt(tokens.get(1));
            int idx=vertIndex * floatsPerVert;
            mesh.vertices[idx++]=parseFloat(tokens.get(3));
            mesh.vertices[idx++]=parseFloat(tokens.get(4));
            mesh.vertices[idx++]=parseFloat(tokens.get(6));
            mesh.vertices[idx++]=parseFloat(tokens.get(7));
            if (allocateNormals) {
              mesh.vertices[idx++]=0.f;
              mesh.vertices[idx++]=0.f;
              mesh.vertices[idx++]=0.f;
            }
          }
          if (tokens.get(0).equals("tri")) {
            triIndex=parseInt(tokens.get(1));
            int idx=triIndex * 3;
            mesh.indices[idx++]=Short.parseShort(tokens.get(2));
            mesh.indices[idx++]=Short.parseShort(tokens.get(3));
            mesh.indices[idx++]=Short.parseShort(tokens.get(4));
          }
          if (tokens.get(0).equals("weight")) {
            weightIndex=parseInt(tokens.get(1));
            int idx=weightIndex * floatsPerWeight;
            mesh.weights[idx++]=parseInt(tokens.get(2));
            mesh.weights[idx++]=parseFloat(tokens.get(3));
            mesh.weights[idx++]=parseFloat(tokens.get(5));
            mesh.weights[idx++]=parseFloat(tokens.get(6));
            mesh.weights[idx++]=parseFloat(tokens.get(7));
          }
        }
      }
    }
    return model;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
}
