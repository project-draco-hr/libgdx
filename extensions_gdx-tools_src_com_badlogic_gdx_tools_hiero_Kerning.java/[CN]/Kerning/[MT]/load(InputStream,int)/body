{
  this.size=size;
  if (input == null)   throw new IllegalArgumentException("input cannot be null.");
  readTableDirectory(input);
  if (headOffset == -1)   throw new IOException("HEAD table not found.");
  if (kernOffset == -1) {
    values=Collections.EMPTY_MAP;
    return;
  }
  values=new HashMap(256);
  if (headOffset < kernOffset) {
    readHEAD(input);
    readKERN(input);
  }
 else {
    readKERN(input);
    readHEAD(input);
  }
  input.close();
  for (Iterator entryIter=values.entrySet().iterator(); entryIter.hasNext(); ) {
    Entry entry=(Entry)entryIter.next();
    List valueList=(List)entry.getValue();
    for (ListIterator valueIter=valueList.listIterator(); valueIter.hasNext(); ) {
      int value=((Integer)valueIter.next()).intValue();
      int glyphCode=value & 0xffff;
      int offset=value >> 16;
      offset=Math.round(offset * scale);
      if (offset == 0)       valueIter.remove();
 else       valueIter.set(new Integer((offset << 16) | glyphCode));
    }
    if (valueList.isEmpty()) {
      entryIter.remove();
    }
 else {
      int[] valueArray=new int[valueList.size()];
      int i=0;
      for (Iterator valueIter=valueList.iterator(); valueIter.hasNext(); i++)       valueArray[i]=((Integer)valueIter.next()).intValue();
      entry.setValue(valueArray);
      kerningPairCount+=valueArray.length;
    }
  }
}
