{
  if (element.getName().equals("layer")) {
    String name=element.getAttribute("name",null);
    int width=element.getIntAttribute("width",0);
    int height=element.getIntAttribute("height",0);
    int tileWidth=element.getParent().getIntAttribute("tilewidth",0);
    int tileHeight=element.getParent().getIntAttribute("tileheight",0);
    boolean visible=element.getIntAttribute("visible",1) == 1;
    float opacity=element.getFloatAttribute("opacity",1.0f);
    TiledMapTileLayer layer=new TiledMapTileLayer(width,height,tileWidth,tileHeight);
    layer.setVisible(visible);
    layer.setOpacity(opacity);
    layer.setName(name);
    TiledMapTileSets tilesets=map.getTileSets();
    Element data=element.getChildByName("data");
    String encoding=data.getAttribute("encoding",null);
    String compression=data.getAttribute("compression",null);
    if (encoding == null) {
      throw new GdxRuntimeException("Unsupported encoding (XML) for TMX Layer Data");
    }
    if (encoding.equals("csv")) {
      String[] array=data.getText().split(",");
      for (int y=0; y < height; y++) {
        for (int x=0; x < width; x++) {
          int id=(int)Long.parseLong(array[y * width + x].trim());
          final boolean flipHorizontally=((id & FLAG_FLIP_HORIZONTALLY) != 0);
          final boolean flipVertically=((id & FLAG_FLIP_VERTICALLY) != 0);
          final boolean flipDiagonally=((id & FLAG_FLIP_DIAGONALLY) != 0);
          id=id & ~MASK_CLEAR;
          tilesets.getTile(id);
          TiledMapTile tile=tilesets.getTile(id);
          if (tile != null) {
            Cell cell=new Cell();
            if (flipDiagonally) {
              if (flipHorizontally && flipVertically) {
                cell.setFlipHorizontally(true);
                cell.setRotation(Cell.ROTATE_270);
              }
 else               if (flipHorizontally) {
                cell.setRotation(Cell.ROTATE_270);
              }
 else               if (flipVertically) {
                cell.setRotation(Cell.ROTATE_90);
              }
 else {
                cell.setFlipVertically(true);
                cell.setRotation(Cell.ROTATE_270);
              }
            }
 else {
              cell.setFlipHorizontally(flipHorizontally);
              cell.setFlipVertically(flipVertically);
            }
            cell.setTile(tile);
            layer.setCell(x,yUp ? height - 1 - y : y,cell);
          }
        }
      }
    }
 else {
      if (encoding.equals("base64")) {
        byte[] bytes=Base64Coder.decode(data.getText());
        if (compression == null) {
          int read=0;
          for (int y=0; y < height; y++) {
            for (int x=0; x < width; x++) {
              int id=unsignedByteToInt(bytes[read++]) | unsignedByteToInt(bytes[read++]) << 8 | unsignedByteToInt(bytes[read++]) << 16 | unsignedByteToInt(bytes[read++]) << 24;
              final boolean flipHorizontally=((id & FLAG_FLIP_HORIZONTALLY) != 0);
              final boolean flipVertically=((id & FLAG_FLIP_VERTICALLY) != 0);
              final boolean flipDiagonally=((id & FLAG_FLIP_DIAGONALLY) != 0);
              id=id & ~MASK_CLEAR;
              tilesets.getTile(id);
              TiledMapTile tile=tilesets.getTile(id);
              if (tile != null) {
                Cell cell=new Cell();
                if (flipDiagonally) {
                  if (flipHorizontally && flipVertically) {
                    cell.setFlipHorizontally(true);
                    cell.setRotation(Cell.ROTATE_270);
                  }
 else                   if (flipHorizontally) {
                    cell.setRotation(Cell.ROTATE_270);
                  }
 else                   if (flipVertically) {
                    cell.setRotation(Cell.ROTATE_90);
                  }
 else {
                    cell.setFlipVertically(true);
                    cell.setRotation(Cell.ROTATE_270);
                  }
                }
 else {
                  cell.setFlipHorizontally(flipHorizontally);
                  cell.setFlipVertically(flipVertically);
                }
                cell.setTile(tile);
                layer.setCell(x,yUp ? height - 1 - y : y,cell);
              }
            }
          }
        }
 else         if (compression.equals("gzip")) {
          GZIPInputStream GZIS=null;
          try {
            GZIS=new GZIPInputStream(new ByteArrayInputStream(bytes),bytes.length);
          }
 catch (          IOException e) {
            throw new GdxRuntimeException("Error Reading TMX Layer Data - IOException: " + e.getMessage());
          }
          byte[] temp=new byte[4];
          for (int y=0; y < height; y++) {
            for (int x=0; x < width; x++) {
              try {
                GZIS.read(temp,0,4);
                int id=unsignedByteToInt(temp[0]) | unsignedByteToInt(temp[1]) << 8 | unsignedByteToInt(temp[2]) << 16 | unsignedByteToInt(temp[3]) << 24;
                final boolean flipHorizontally=((id & FLAG_FLIP_HORIZONTALLY) != 0);
                final boolean flipVertically=((id & FLAG_FLIP_VERTICALLY) != 0);
                final boolean flipDiagonally=((id & FLAG_FLIP_DIAGONALLY) != 0);
                id=id & ~MASK_CLEAR;
                tilesets.getTile(id);
                TiledMapTile tile=tilesets.getTile(id);
                if (tile != null) {
                  Cell cell=new Cell();
                  if (flipDiagonally) {
                    if (flipHorizontally && flipVertically) {
                      cell.setFlipHorizontally(true);
                      cell.setRotation(Cell.ROTATE_270);
                    }
 else                     if (flipHorizontally) {
                      cell.setRotation(Cell.ROTATE_270);
                    }
 else                     if (flipVertically) {
                      cell.setRotation(Cell.ROTATE_90);
                    }
 else {
                      cell.setFlipVertically(true);
                      cell.setRotation(Cell.ROTATE_270);
                    }
                  }
 else {
                    cell.setFlipHorizontally(flipHorizontally);
                    cell.setFlipVertically(flipVertically);
                  }
                  cell.setTile(tile);
                  layer.setCell(x,yUp ? height - 1 - y : y,cell);
                }
              }
 catch (              IOException e) {
                throw new GdxRuntimeException("Error Reading TMX Layer Data.",e);
              }
            }
          }
        }
 else         if (compression.equals("zlib")) {
          Inflater zlib=new Inflater();
          byte[] temp=new byte[4];
          zlib.setInput(bytes,0,bytes.length);
          for (int y=0; y < height; y++) {
            for (int x=0; x < width; x++) {
              try {
                zlib.inflate(temp,0,4);
                int id=unsignedByteToInt(temp[0]) | unsignedByteToInt(temp[1]) << 8 | unsignedByteToInt(temp[2]) << 16 | unsignedByteToInt(temp[3]) << 24;
                final boolean flipHorizontally=((id & FLAG_FLIP_HORIZONTALLY) != 0);
                final boolean flipVertically=((id & FLAG_FLIP_VERTICALLY) != 0);
                final boolean flipDiagonally=((id & FLAG_FLIP_DIAGONALLY) != 0);
                id=id & ~MASK_CLEAR;
                tilesets.getTile(id);
                TiledMapTile tile=tilesets.getTile(id);
                if (tile != null) {
                  Cell cell=new Cell();
                  if (flipDiagonally) {
                    if (flipHorizontally && flipVertically) {
                      cell.setFlipHorizontally(true);
                      cell.setRotation(Cell.ROTATE_270);
                    }
 else                     if (flipHorizontally) {
                      cell.setRotation(Cell.ROTATE_270);
                    }
 else                     if (flipVertically) {
                      cell.setRotation(Cell.ROTATE_90);
                    }
 else {
                      cell.setFlipVertically(true);
                      cell.setRotation(Cell.ROTATE_270);
                    }
                  }
 else {
                    cell.setFlipHorizontally(flipHorizontally);
                    cell.setFlipVertically(flipVertically);
                  }
                  cell.setTile(tile);
                  layer.setCell(x,yUp ? height - 1 - y : y,cell);
                }
              }
 catch (              DataFormatException e) {
                throw new GdxRuntimeException("Error Reading TMX Layer Data.",e);
              }
            }
          }
        }
      }
 else {
        throw new GdxRuntimeException("Unrecognised encoding (" + encoding + ") for TMX Layer Data");
      }
    }
    Element properties=element.getChildByName("properties");
    if (properties != null) {
      loadProperties(layer.getProperties(),properties);
    }
    map.getLayers().add(layer);
  }
}
