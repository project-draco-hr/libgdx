{
  if (!plane.isFrontFacing(packet.normalizedVelocity)) {
    culledTriangles++;
    return;
  }
  float t0, t1;
  boolean embeddedInPlane=false;
  float signedDistanceToTrianglePlane=plane.distance(packet.position);
  float normalDotVelocity=plane.normal.dot(packet.velocity);
  if (normalDotVelocity == 0) {
    if (Math.abs(signedDistanceToTrianglePlane) >= 1.0f) {
      earlyOutTriangles++;
      return;
    }
 else {
      embeddedInPlane=true;
      t0=0;
      t1=1;
    }
  }
 else {
    t0=(-1 - signedDistanceToTrianglePlane) / normalDotVelocity;
    t1=(1 - signedDistanceToTrianglePlane) / normalDotVelocity;
    if (t0 > t1) {
      float tmp=t1;
      t1=t0;
      t0=tmp;
    }
    if (t0 > 1 || t1 < 0) {
      earlyOutTriangles++;
      return;
    }
    if (t0 < 0)     t0=0;
    if (t1 < 0)     t1=0;
    if (t0 > 1)     t0=1;
    if (t1 > 1)     t1=1;
  }
  Vector collisionPoint=null;
  boolean foundCollision=false;
  float t=1.0f;
  if (!embeddedInPlane) {
    planeIntersectionPoint.set(packet.position).sub(plane.normal);
    planeIntersectionPoint.add(packet.velocity.x * t0,packet.velocity.y * t0,packet.velocity.z * t0);
    earlyOutTriangles++;
    if (Intersector.isPointInTriangle(planeIntersectionPoint,p1,p2,p3)) {
      foundCollision=true;
      t=t0;
      collisionPoint=planeIntersectionPoint;
    }
  }
  if (foundCollision == false) {
    Vector velocity=packet.velocity;
    Vector base=packet.position;
    float velocitySquaredLength=velocity.len2();
    float a, b, c;
    a=velocitySquaredLength;
    b=2 * (velocity.dot(base.tmp().sub(p1)));
    c=p1.tmp().sub(base).len2() - 1;
    float root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      t=root;
      foundCollision=true;
      collisionPoint=p1;
    }
    b=2 * (velocity.dot(base.tmp().sub(p2)));
    c=p2.tmp().sub(base).len2() - 1;
    root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      t=root;
      foundCollision=true;
      collisionPoint=p2;
    }
    b=2 * (velocity.dot(base.tmp().sub(p3)));
    c=p3.tmp().sub(base).len2() - 1;
    root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      t=root;
      foundCollision=true;
      collisionPoint=p3;
    }
    edge.set(p2).sub(p1);
    baseToVertex.set(p1).sub(base);
    float edgeSquaredLength=edge.len2();
    float edgeDotVelocity=edge.dot(velocity);
    float edgeDotBaseToVertex=edge.dot(baseToVertex);
    a=edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
    b=edgeSquaredLength * (2 * velocity.dot(baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
    c=edgeSquaredLength * (1 - baseToVertex.len2()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
    root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      float f=(edgeDotVelocity * root - edgeDotBaseToVertex) / edgeSquaredLength;
      if (f > 0 && f < 1) {
        t=root;
        foundCollision=true;
        collisionPoint=p1.tmp2().add(edge.tmp().mul(f));
      }
    }
    edge.set(p3).sub(p2);
    baseToVertex.set(p2).sub(base);
    edgeSquaredLength=edge.len2();
    edgeDotVelocity=edge.dot(velocity);
    edgeDotBaseToVertex=edge.dot(baseToVertex);
    a=edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
    b=edgeSquaredLength * (2 * velocity.dot(baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
    c=edgeSquaredLength * (1 - baseToVertex.len2()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
    root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      float f=(edgeDotVelocity * root - edgeDotBaseToVertex) / edgeSquaredLength;
      if (f > 0 && f < 1) {
        t=root;
        foundCollision=true;
        collisionPoint=p2.tmp2().add(edge.tmp().mul(f));
      }
    }
    edge.set(p1).sub(p3);
    baseToVertex.set(p3).sub(base);
    edgeSquaredLength=edge.len2();
    edgeDotVelocity=edge.dot(velocity);
    edgeDotBaseToVertex=edge.dot(baseToVertex);
    a=edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;
    b=edgeSquaredLength * (2 * velocity.dot(baseToVertex)) - 2 * edgeDotVelocity * edgeDotBaseToVertex;
    c=edgeSquaredLength * (1 - baseToVertex.len2()) + edgeDotBaseToVertex * edgeDotBaseToVertex;
    root=Intersector.getLowestPositiveRoot(a,b,c);
    if (root != Float.NaN && root < t) {
      float f=(edgeDotVelocity * root - edgeDotBaseToVertex) / edgeSquaredLength;
      if (f > 0 && f < 1) {
        t=root;
        foundCollision=true;
        collisionPoint=p3.tmp2().add(edge.tmp().mul(f));
      }
    }
  }
  if (foundCollision == true) {
    float distToCollision=t * packet.velocity.len();
    if (packet.foundCollision == false || distToCollision < packet.nearestDistance) {
      packet.nearestDistance=distToCollision;
      packet.intersectionPoint.set(collisionPoint);
      packet.foundCollision=true;
    }
  }
}
