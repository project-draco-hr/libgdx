{
  long cnt=0;
  ModelNode node=new ModelNode();
  Array<ModelNode> children=new Array<ModelNode>();
  Array<ModelNodePart> parts=new Array<ModelNodePart>();
  result.nodes.add(node);
  while ((din.available() > 0) && (cnt < length)) {
    final byte type=din.readByte();
    final long size=readSize(type);
    cnt+=1 + getSize(type) + size;
    if ((type & TYPE_MASK) == G3DB_TAG_ID)     node.id=readString(size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_BONE)     din.skipBytes((int)size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_TRANSLATE)     node.translation=readVector3(size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_ROTATE)     node.rotation=readQuaternion(size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_SCALE)     node.scale=readVector3(size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_MESH)     node.meshId=readString(size);
 else     if ((type & TYPE_MASK) == G3DB_TAG_PARTMATERIAL)     parts.add(readMeshPartMaterial(size));
 else     if ((type & TYPE_MASK) == G3DB_TAG_NODE)     children.add(readNode(size));
 else {
      din.skipBytes((int)size);
      Gdx.app.log("G3dbModelLoader","Unknown node tag: " + type + "["+ size+ "], skipping");
    }
  }
  if (children.size > 0) {
    node.children=new ModelNode[children.size];
    for (int i=0; i < children.size; i++)     node.children[i]=children.get(i);
  }
  if (parts.size > 0) {
    node.parts=new ModelNodePart[parts.size];
    for (int i=0; i < parts.size; i++)     node.parts[i]=parts.get(i);
  }
  return node;
}
