{
  final Rot xfq=xf.q;
  final Vec2 xfp=xf.p;
  float tempx, tempy;
  tempx=input.p1.x - xfp.x;
  tempy=input.p1.y - xfp.y;
  final float p1x=xfq.c * tempx + xfq.s * tempy;
  final float p1y=-xfq.s * tempx + xfq.c * tempy;
  tempx=input.p2.x - xfp.x;
  tempy=input.p2.y - xfp.y;
  final float p2x=xfq.c * tempx + xfq.s * tempy;
  final float p2y=-xfq.s * tempx + xfq.c * tempy;
  final float dx=p2x - p1x;
  final float dy=p2y - p1y;
  float lower=0, upper=input.maxFraction;
  int index=-1;
  for (int i=0; i < m_count; ++i) {
    Vec2 normal=m_normals[i];
    Vec2 vertex=m_vertices[i];
    float tempxn=vertex.x - p1x;
    float tempyn=vertex.y - p1y;
    final float numerator=normal.x * tempxn + normal.y * tempyn;
    final float denominator=normal.x * dx + normal.y * dy;
    if (denominator == 0.0f) {
      if (numerator < 0.0f) {
        return false;
      }
    }
 else {
      if (denominator < 0.0f && numerator < lower * denominator) {
        lower=numerator / denominator;
        index=i;
      }
 else       if (denominator > 0.0f && numerator < upper * denominator) {
        upper=numerator / denominator;
      }
    }
    if (upper < lower) {
      return false;
    }
  }
  assert(0.0f <= lower && lower <= input.maxFraction);
  if (index >= 0) {
    output.fraction=lower;
    Vec2 normal=m_normals[index];
    Vec2 out=output.normal;
    out.x=xfq.c * normal.x - xfq.s * normal.y;
    out.y=xfq.s * normal.x + xfq.c * normal.y;
    return true;
  }
  return false;
}
