{
  ArrayList<VTIndex> vertCombos=new ArrayList<VTIndex>();
  short[] indices=new short[triangles.length * 3];
  int idx=0;
  short vertIdx=0;
  for (int i=0; i < triangles.length; i++) {
    MD2Triangle triangle=triangles[i];
    for (int j=0; j < 3; j++) {
      VTIndex vert=null;
      boolean contains=false;
      for (int k=0; k < vertCombos.size(); k++) {
        VTIndex vIdx=vertCombos.get(k);
        if (vIdx.vIdx == triangle.vertices[j] && vIdx.tIdx == triangle.texCoords[j]) {
          vert=vIdx;
          contains=true;
          break;
        }
      }
      if (!contains) {
        vert=new VTIndex(triangle.vertices[j],triangle.texCoords[j],vertIdx);
        vertCombos.add(vert);
        vertIdx++;
      }
      indices[idx++]=vert.nIdx;
    }
  }
  idx=0;
  float[] uvs=new float[vertCombos.size() * 2];
  for (int i=0; i < vertCombos.size(); i++) {
    VTIndex vtI=vertCombos.get(i);
    uvs[idx++]=texCoords[vtI.tIdx * 2];
    uvs[idx++]=texCoords[vtI.tIdx * 2 + 1];
  }
  for (int i=0; i < frames.length; i++) {
    MD2Frame frame=frames[i];
    idx=0;
    float[] newVerts=new float[vertCombos.size() * 3];
    for (int j=0; j < vertCombos.size(); j++) {
      VTIndex vIdx=vertCombos.get(j);
      newVerts[idx++]=frame.vertices[vIdx.vIdx * 3];
      newVerts[idx++]=frame.vertices[vIdx.vIdx * 3 + 1];
      newVerts[idx++]=frame.vertices[vIdx.vIdx * 3 + 2];
    }
    frame.vertices=newVerts;
    ByteBuffer buffer=ByteBuffer.allocateDirect(4 * frame.vertices.length);
    buffer.order(ByteOrder.nativeOrder());
    FloatBuffer fbuffer=buffer.asFloatBuffer();
    fbuffer.put(frame.vertices);
    frame.verticesBuffer=fbuffer;
  }
  header.numVertices=vertCombos.size();
  return new MD2Mesh(app,frames,indices,uvs,null);
}
