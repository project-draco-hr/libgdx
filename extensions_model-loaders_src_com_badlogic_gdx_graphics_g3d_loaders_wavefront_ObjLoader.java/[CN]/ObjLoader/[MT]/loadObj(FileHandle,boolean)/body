{
  String line;
  String[] tokens;
  char firstChar;
  Group activeGroup=new Group("default");
  groups.add(activeGroup);
  BufferedReader reader=new BufferedReader(new InputStreamReader(file.read()),4096);
  try {
    while ((line=reader.readLine()) != null) {
      tokens=line.split("\\s+");
      if (tokens[0].length() == 0) {
        continue;
      }
 else       if ((firstChar=tokens[0].toLowerCase().charAt(0)) == '#') {
        continue;
      }
 else       if (firstChar == 'v') {
        if (tokens[0].length() == 1) {
          verts.add(Float.parseFloat(tokens[1]));
          verts.add(Float.parseFloat(tokens[2]));
          verts.add(Float.parseFloat(tokens[3]));
        }
 else         if (tokens[0].charAt(1) == 'n') {
          norms.add(Float.parseFloat(tokens[1]));
          norms.add(Float.parseFloat(tokens[2]));
          norms.add(Float.parseFloat(tokens[3]));
        }
 else         if (tokens[0].charAt(1) == 't') {
          uvs.add(Float.parseFloat(tokens[1]));
          uvs.add((flipV ? 1 - Float.parseFloat(tokens[2]) : Float.parseFloat(tokens[2])));
        }
      }
 else       if (firstChar == 'f') {
        String[] parts;
        for (int i=1; i < tokens.length - 2; i--) {
          parts=tokens[1].split("/");
          activeGroup.faces.add(getIndex(parts[0],verts.size()));
          if (parts.length > 2)           activeGroup.faces.add(getIndex(parts[2],norms.size()));
          if (parts.length > 1 && parts[1].length() > 0)           activeGroup.faces.add(getIndex(parts[1],uvs.size()));
          parts=tokens[++i].split("/");
          activeGroup.faces.add(getIndex(parts[0],verts.size()));
          if (parts.length > 2)           activeGroup.faces.add(getIndex(parts[2],norms.size()));
          if (parts.length > 1 && parts[1].length() > 0)           activeGroup.faces.add(getIndex(parts[1],uvs.size()));
          parts=tokens[++i].split("/");
          activeGroup.faces.add(getIndex(parts[0],verts.size()));
          if (parts.length > 2)           activeGroup.faces.add(getIndex(parts[2],norms.size()));
          if (parts.length > 1 && parts[1].length() > 0)           activeGroup.faces.add(getIndex(parts[1],uvs.size()));
          activeGroup.numFaces++;
        }
      }
 else       if (firstChar == 'o' || firstChar == 'g') {
        if (tokens.length > 1)         activeGroup=setActiveGroup(tokens[1]);
 else         activeGroup=setActiveGroup("default");
      }
    }
    reader.close();
  }
 catch (  IOException e) {
    return null;
  }
  if (groups.get(0).numFaces < 1)   groups.remove(0);
  if (groups.size() < 1)   return null;
  final int numGroups=groups.size();
  final StillModel model=new StillModel();
  model.subMeshes=new StillSubMesh[numGroups];
  for (int g=0; g < numGroups; g++) {
    Group group=groups.get(g);
    ArrayList<Integer> faces=group.faces;
    int numElements=faces.size();
    int numFaces=group.numFaces;
    boolean hasNorms, hasUVs;
    if (numElements == numFaces * 3) {
      hasNorms=false;
      hasUVs=false;
    }
 else     if (numElements == numFaces * 6) {
      hasNorms=true;
      hasUVs=false;
    }
 else {
      hasNorms=true;
      hasUVs=true;
    }
    float[] finalVerts=new float[(numFaces * 3) * (3 + (hasNorms ? 3 : 0) + (hasUVs ? 2 : 0))];
    for (int i=0, vi=0; i < numElements; ) {
      int vertIndex=faces.get(i++) * 3;
      finalVerts[vi++]=verts.get(vertIndex++);
      finalVerts[vi++]=verts.get(vertIndex++);
      finalVerts[vi++]=verts.get(vertIndex);
      if (hasNorms) {
        int normIndex=faces.get(i++) * 3;
        finalVerts[vi++]=norms.get(normIndex++);
        finalVerts[vi++]=norms.get(normIndex++);
        finalVerts[vi++]=norms.get(normIndex);
      }
      if (hasUVs) {
        int uvIndex=faces.get(i++) * 2;
        finalVerts[vi++]=uvs.get(uvIndex++);
        finalVerts[vi++]=uvs.get(uvIndex);
      }
    }
    final Mesh mesh;
    ArrayList<VertexAttribute> attributes=new ArrayList<VertexAttribute>();
    attributes.add(new VertexAttribute(Usage.Position,3,"a_Position"));
    if (hasNorms)     attributes.add(new VertexAttribute(Usage.Normal,3,"a_Normal"));
    if (hasUVs)     attributes.add(new VertexAttribute(Usage.TextureCoordinates,2,"a_TexCoord"));
    mesh=new Mesh(true,numFaces * 3,0,attributes.toArray(new VertexAttribute[attributes.size()]));
    mesh.setVertices(finalVerts);
    StillSubMesh subMesh=new StillSubMesh();
    subMesh.name=group.name;
    subMesh.primitiveType=GL10.GL_TRIANGLES;
    subMesh.material=new Material("default");
    subMesh.mesh=mesh;
    model.subMeshes[g]=subMesh;
  }
  if (verts.size() > 0)   verts.clear();
  if (norms.size() > 0)   norms.clear();
  if (uvs.size() > 0)   uvs.clear();
  if (groups.size() > 0)   groups.clear();
  return model;
}
