{
  if (text == null)   throw new IllegalArgumentException("text cannot be null.");
  if (text.length() == 0)   return emptyDisplayList;
  if (color == null)   throw new IllegalArgumentException("color cannot be null.");
  x-=paddingLeft;
  y-=paddingTop;
  String displayListKey=text.substring(startIndex,endIndex);
  GL11.glColor4f(color.r,color.g,color.b,color.a);
  DisplayList displayList=null;
  if (displayListCaching && queuedGlyphs.isEmpty()) {
    if (baseDisplayListID == -1) {
      baseDisplayListID=GL11.glGenLists(DISPLAY_LIST_CACHE_SIZE);
      if (baseDisplayListID == 0) {
        baseDisplayListID=-1;
        displayListCaching=false;
        return new DisplayList();
      }
    }
    displayList=(DisplayList)displayLists.get(displayListKey);
    if (displayList != null) {
      if (displayList.invalid)       displayList.invalid=false;
 else {
        GL11.glTranslatef(x,y,0);
        GL11.glCallList(displayList.id);
        GL11.glTranslatef(-x,-y,0);
        return displayList;
      }
    }
 else     if (displayList == null) {
      displayList=new DisplayList();
      int displayListCount=displayLists.size();
      displayLists.put(displayListKey,displayList);
      if (displayListCount < DISPLAY_LIST_CACHE_SIZE)       displayList.id=baseDisplayListID + displayListCount;
 else       displayList.id=eldestDisplayListID;
    }
  }
  GL11.glTranslatef(x,y,0);
  if (displayList != null)   GL11.glNewList(displayList.id,GL11.GL_COMPILE_AND_EXECUTE);
  char[] chars=text.substring(0,endIndex).toCharArray();
  GlyphVector vector=font.layoutGlyphVector(GlyphPage.renderContext,chars,0,chars.length,Font.LAYOUT_LEFT_TO_RIGHT);
  int maxWidth=0, totalHeight=0, lines=0;
  int extraX=0, extraY=ascent;
  boolean startNewLine=false;
  Texture lastBind=null;
  int offsetX=0;
  for (int glyphIndex=0, n=vector.getNumGlyphs(); glyphIndex < n; glyphIndex++) {
    int charIndex=vector.getGlyphCharIndex(glyphIndex);
    if (charIndex < startIndex)     continue;
    if (charIndex > endIndex)     break;
    int codePoint=text.codePointAt(charIndex);
    Rectangle bounds=getGlyphBounds(vector,glyphIndex,codePoint);
    bounds.x+=offsetX;
    Glyph glyph=getGlyph(vector.getGlyphCode(glyphIndex),codePoint,bounds,vector,glyphIndex);
    if (startNewLine && codePoint != '\n') {
      extraX=-bounds.x;
      startNewLine=false;
    }
    if (glyph.getTexture() == null && missingGlyph != null && glyph.isMissing())     glyph=missingGlyph;
    if (glyph.getTexture() != null) {
      Texture texture=glyph.getTexture();
      if (lastBind != null && lastBind != texture) {
        GL11.glEnd();
        lastBind=null;
      }
      if (lastBind == null) {
        texture.bind();
        GL11.glBegin(GL11.GL_QUADS);
        lastBind=texture;
      }
      int glyphX=bounds.x + extraX;
      int glyphY=bounds.y + extraY;
      GL11.glTexCoord2f(glyph.getU(),glyph.getV());
      GL11.glVertex3f(glyphX,glyphY,0);
      GL11.glTexCoord2f(glyph.getU(),glyph.getV2());
      GL11.glVertex3f(glyphX,glyphY + glyph.getHeight(),0);
      GL11.glTexCoord2f(glyph.getU2(),glyph.getV2());
      GL11.glVertex3f(glyphX + glyph.getWidth(),glyphY + glyph.getHeight(),0);
      GL11.glTexCoord2f(glyph.getU2(),glyph.getV());
      GL11.glVertex3f(glyphX + glyph.getWidth(),glyphY,0);
    }
    if (glyphIndex > 0)     extraX+=paddingRight + paddingLeft + paddingAdvanceX;
    maxWidth=Math.max(maxWidth,bounds.x + extraX + bounds.width);
    totalHeight=Math.max(totalHeight,ascent + bounds.y + bounds.height);
    if (codePoint == '\n') {
      startNewLine=true;
      extraY+=getLineHeight();
      lines++;
      totalHeight=0;
    }
 else     if (nativeRendering)     offsetX+=bounds.width;
  }
  if (lastBind != null)   GL11.glEnd();
  if (displayList != null) {
    GL11.glEndList();
    if (!queuedGlyphs.isEmpty())     displayList.invalid=true;
  }
  GL11.glTranslatef(-x,-y,0);
  if (displayList == null)   displayList=new DisplayList();
  displayList.width=(short)maxWidth;
  displayList.height=(short)(lines * getLineHeight() + totalHeight);
  return displayList;
}
