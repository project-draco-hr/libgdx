{
  if (maxVertices < 0)   throw new IllegalArgumentException("maxVertices must be > 0");
  if (coordsSize < 2 || coordsSize > 4)   throw new IllegalArgumentException("coordsSize must be >= 2 and <= 4");
  if (hasColors && (colorsSize < 3 || colorsSize > 4))   throw new IllegalArgumentException("colorSize must be >= 2 and <= 4");
  if (hasTexCoords && (texCoordSize < 1 || texCoordSize > 4))   throw new IllegalArgumentException("texCoordSize must be >= 1 and <= 4");
  if (hasIndices && maxIndices < 1)   throw new IllegalArgumentException("maxIndices has to be >= 1");
  this.hasColors=hasColors;
  this.hasNormals=hasNormals;
  this.hasTexCoords=hasTexCoords;
  this.numTexCoords=numTexCoords;
  this.coordsSize=coordsSize;
  this.colorsSize=colorsSize;
  this.texCoordsSize=texCoordSize;
  vertexSize+=coordsSize * 4;
  colorsOffset+=vertexSize;
  normalsOffset+=vertexSize;
  texCoordsOffset+=vertexSize;
  if (hasColors) {
    vertexSize+=colorsSize * 4;
    normalsOffset+=colorsSize * 4;
    texCoordsOffset+=colorsSize * 4;
  }
  if (hasNormals) {
    vertexSize+=3 * 4;
    texCoordsOffset+=3 * 4;
  }
  if (hasTexCoords)   vertexSize+=texCoordSize * numTexCoords * 4;
  vertexSizeInt=vertexSize / 4;
  verticesArray=new int[vertexSize / 4 * maxVertices];
  ByteBuffer buffer=ByteBuffer.allocateDirect(vertexSize * maxVertices);
  buffer.order(ByteOrder.nativeOrder());
  verticesBuffer=buffer.asIntBuffer();
  if (hasIndices) {
    indicesArray=new short[maxIndices];
    buffer=ByteBuffer.allocateDirect(maxIndices * 2);
    buffer.order(ByteOrder.nativeOrder());
    indicesBuffer=buffer.asShortBuffer();
    this.maxIndices=maxIndices;
  }
 else {
    this.maxIndices=0;
    indicesArray=null;
    indicesBuffer=null;
  }
}
