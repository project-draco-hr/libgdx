{
  sizeInvalid=false;
  ArrayList<Cell> cells=this.cells;
  if (cells.size() > 0 && !cells.get(cells.size() - 1).endRow)   endRow();
  columnMinWidth=ensureSize(columnMinWidth,columns);
  rowMinHeight=ensureSize(rowMinHeight,rows);
  columnPrefWidth=ensureSize(columnPrefWidth,columns);
  rowPrefHeight=ensureSize(rowPrefHeight,rows);
  columnWidth=ensureSize(columnWidth,columns);
  rowHeight=ensureSize(rowHeight,rows);
  expandWidth=ensureSize(expandWidth,columns);
  expandHeight=ensureSize(expandHeight,rows);
  float spaceRightLast=0;
  for (int i=0, n=cells.size(); i < n; i++) {
    Cell c=cells.get(i);
    if (c.ignore)     continue;
    if (c.expandY != 0 && expandHeight[c.row] == 0)     expandHeight[c.row]=c.expandY;
    if (c.colspan == 1 && c.expandX != 0 && expandWidth[c.column] == 0)     expandWidth[c.column]=c.expandX;
    c.computedPadLeft=w(c.padLeft,c) + (c.column == 0 ? 0 : Math.max(0,w(c.spaceLeft,c) - spaceRightLast));
    c.computedPadTop=h(c.padTop,c);
    if (c.cellAboveIndex != -1) {
      Cell above=cells.get(c.cellAboveIndex);
      c.computedPadTop+=Math.max(0,h(c.spaceTop,c) - h(above.spaceBottom,above));
    }
    float spaceRight=w(c.spaceRight,c);
    c.computedPadRight=w(c.padRight,c) + ((c.column + c.colspan) == columns ? 0 : spaceRight);
    c.computedPadBottom=h(c.padBottom,c) + (c.row == rows - 1 ? 0 : h(c.spaceBottom,c));
    spaceRightLast=spaceRight;
    float prefWidth=c.prefWidth.get(c);
    float prefHeight=c.prefHeight.get(c);
    float minWidth=c.minWidth.get(c);
    float minHeight=c.minHeight.get(c);
    float maxWidth=c.maxWidth.get(c);
    float maxHeight=c.maxHeight.get(c);
    if (prefWidth < minWidth)     prefWidth=minWidth;
    if (prefHeight < minHeight)     prefHeight=minHeight;
    if (maxWidth > 0 && prefWidth > maxWidth)     prefWidth=maxWidth;
    if (maxHeight > 0 && prefHeight > maxHeight)     prefHeight=maxHeight;
    if (c.colspan == 1) {
      float hpadding=c.computedPadLeft + c.computedPadRight;
      columnPrefWidth[c.column]=Math.max(columnPrefWidth[c.column],prefWidth + hpadding);
      columnMinWidth[c.column]=Math.max(columnMinWidth[c.column],minWidth + hpadding);
    }
    float vpadding=c.computedPadTop + c.computedPadBottom;
    rowPrefHeight[c.row]=Math.max(rowPrefHeight[c.row],prefHeight + vpadding);
    rowMinHeight[c.row]=Math.max(rowMinHeight[c.row],minHeight + vpadding);
  }
  outer:   for (int i=0, n=cells.size(); i < n; i++) {
    Cell c=cells.get(i);
    if (c.ignore || c.expandX == 0)     continue;
    for (int column=c.column, nn=column + c.colspan; column < nn; column++)     if (expandWidth[column] != 0)     continue outer;
    for (int column=c.column, nn=column + c.colspan; column < nn; column++)     expandWidth[column]=c.expandX;
  }
  for (int i=0, n=cells.size(); i < n; i++) {
    Cell c=cells.get(i);
    if (c.ignore || c.colspan == 1)     continue;
    float minWidth=c.minWidth.get(c);
    float prefWidth=c.prefWidth.get(c);
    float maxWidth=c.maxWidth.get(c);
    if (prefWidth < minWidth)     prefWidth=minWidth;
    if (maxWidth > 0 && prefWidth > maxWidth)     prefWidth=maxWidth;
    float spannedMinWidth=-(c.computedPadLeft + c.computedPadRight), spannedPrefWidth=spannedMinWidth;
    for (int column=c.column, nn=column + c.colspan; column < nn; column++) {
      spannedMinWidth+=columnMinWidth[column];
      spannedPrefWidth+=columnPrefWidth[column];
    }
    float totalExpandWidth=0;
    for (int column=c.column, nn=column + c.colspan; column < nn; column++)     totalExpandWidth+=expandWidth[column];
    float extraMinWidth=Math.max(0,minWidth - spannedMinWidth);
    float extraPrefWidth=Math.max(0,prefWidth - spannedPrefWidth);
    for (int column=c.column, nn=column + c.colspan; column < nn; column++) {
      float ratio=totalExpandWidth == 0 ? 1f / c.colspan : expandWidth[column] / totalExpandWidth;
      columnMinWidth[column]+=extraMinWidth * ratio;
      columnPrefWidth[column]+=extraPrefWidth * ratio;
    }
  }
  float uniformMinWidth=0, uniformMinHeight=0;
  float uniformPrefWidth=0, uniformPrefHeight=0;
  for (int i=0, n=cells.size(); i < n; i++) {
    Cell c=cells.get(i);
    if (c.ignore)     continue;
    if (c.uniformX == Boolean.TRUE && c.colspan == 1) {
      float hpadding=c.computedPadLeft + c.computedPadRight;
      uniformMinWidth=Math.max(uniformMinWidth,columnMinWidth[c.column] - hpadding);
      uniformPrefWidth=Math.max(uniformPrefWidth,columnPrefWidth[c.column] - hpadding);
    }
    if (c.uniformY == Boolean.TRUE) {
      float vpadding=c.computedPadTop + c.computedPadBottom;
      uniformMinHeight=Math.max(uniformMinHeight,rowMinHeight[c.row] - vpadding);
      uniformPrefHeight=Math.max(uniformPrefHeight,rowPrefHeight[c.row] - vpadding);
    }
  }
  if (uniformPrefWidth > 0 || uniformPrefHeight > 0) {
    for (int i=0, n=cells.size(); i < n; i++) {
      Cell c=cells.get(i);
      if (c.ignore)       continue;
      if (uniformPrefWidth > 0 && c.uniformX == Boolean.TRUE && c.colspan == 1) {
        float hpadding=c.computedPadLeft + c.computedPadRight;
        columnMinWidth[c.column]=uniformMinWidth + hpadding;
        columnPrefWidth[c.column]=uniformPrefWidth + hpadding;
      }
      if (uniformPrefHeight > 0 && c.uniformY == Boolean.TRUE) {
        float vpadding=c.computedPadTop + c.computedPadBottom;
        rowMinHeight[c.row]=uniformMinHeight + vpadding;
        rowPrefHeight[c.row]=uniformPrefHeight + vpadding;
      }
    }
  }
  tableMinWidth=0;
  tableMinHeight=0;
  tablePrefWidth=0;
  tablePrefHeight=0;
  for (int i=0; i < columns; i++) {
    tableMinWidth+=columnMinWidth[i];
    tablePrefWidth+=columnPrefWidth[i];
  }
  for (int i=0; i < rows; i++) {
    tableMinHeight+=rowMinHeight[i];
    tablePrefHeight+=Math.max(rowMinHeight[i],rowPrefHeight[i]);
  }
  float hpadding=w(padLeft) + w(padRight);
  float vpadding=h(padTop) + h(padBottom);
  tableMinWidth=tableMinWidth + hpadding;
  tableMinHeight=tableMinHeight + vpadding;
  tablePrefWidth=Math.max(tablePrefWidth + hpadding,tableMinWidth);
  tablePrefHeight=Math.max(tablePrefHeight + vpadding,tableMinHeight);
}
