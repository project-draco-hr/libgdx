{
  if (value instanceof ObjectMap) {
    ObjectMap<String,Object> map=(ObjectMap)value;
    Serializer serializer=classToSerializer.get(type);
    if (serializer != null)     return serializer.read(this,map,type);
    Object object=newInstance(type,map);
    if (object instanceof Serializable) {
      ((Serializable)object).read(this,map);
      return object;
    }
    if (object instanceof ObjectMap) {
      ObjectMap result=(ObjectMap)object;
      for (      Entry entry : map.entries())       result.put(entry.key,readValue(String.class,entry.value));
      return result;
    }
    if (object instanceof HashMap) {
      HashMap result=(HashMap)object;
      for (      Entry entry : map.entries())       result.put(entry.key,readValue(String.class,entry.value));
      return result;
    }
    ObjectMap<String,Field> fields=typeToFields.get(type);
    if (fields == null)     fields=cacheFields(type);
    for (    Entry<String,Object> entry : map.entries()) {
      Field field=fields.get(entry.key);
      if (field == null)       throw new SerializationException("Unable to find field: " + entry.key + " ("+ type.getName()+ ")");
      try {
        field.set(object,readValue(field.getType(),entry.value));
      }
 catch (      Exception ex) {
        throw new SerializationException("Error setting field: " + field.getName() + " ("+ type.getName()+ ")",ex);
      }
    }
    return object;
  }
  if (value instanceof Array) {
    Array array=(Array)value;
    if (type.isAssignableFrom(Array.class)) {
      Array newArray=new Array(array.size);
      for (int i=0, n=array.size; i < n; i++)       newArray.add(readValue(String.class,array.get(i)));
      return newArray;
    }
    if (type.isAssignableFrom(ArrayList.class)) {
      ArrayList newArray=new ArrayList(array.size);
      for (int i=0, n=array.size; i < n; i++)       newArray.add(readValue(String.class,array.get(i)));
      return newArray;
    }
    if (type.isArray()) {
      Class componentType=type.getComponentType();
      Object newArray=java.lang.reflect.Array.newInstance(componentType,array.size);
      for (int i=0, n=array.size; i < n; i++)       java.lang.reflect.Array.set(newArray,i,readValue(componentType,array.get(i)));
      return newArray;
    }
    throw new SerializationException("Unable to convert value to required type: " + value + " ("+ type.getName()+ ")");
  }
  if (value instanceof Float) {
    Float floatValue=(Float)value;
    try {
      if (type == int.class || type == Integer.class)       return floatValue.intValue();
      if (type == float.class || type == Float.class)       return floatValue;
      if (type == long.class || type == Long.class)       return floatValue.longValue();
      if (type == double.class || type == Double.class)       return floatValue.doubleValue();
      if (type == short.class || type == Short.class)       return floatValue.shortValue();
      if (type == byte.class || type == Byte.class)       return floatValue.byteValue();
    }
 catch (    NumberFormatException ignored) {
    }
    value=String.valueOf(value);
  }
  if (value instanceof Boolean)   value=String.valueOf(value);
  if (value instanceof String) {
    String string=(String)value;
    if (type == String.class || value == null)     return value;
    try {
      if (type == int.class || type == Integer.class)       return Integer.valueOf(string);
      if (type == float.class || type == Float.class)       return Float.valueOf(string);
      if (type == long.class || type == Long.class)       return Long.valueOf(string);
      if (type == double.class || type == Double.class)       return Double.valueOf(string);
      if (type == short.class || type == Short.class)       return Short.valueOf(string);
      if (type == byte.class || type == Byte.class)       return Byte.valueOf(string);
    }
 catch (    NumberFormatException ignored) {
    }
    if (type == boolean.class || type == Boolean.class)     return Boolean.valueOf(string);
    if (type == char.class || type == Character.class)     return string.charAt(0);
    if (type.isEnum()) {
      Object[] constants=type.getEnumConstants();
      for (int i=0, n=constants.length; i < n; i++)       if (string.equals(constants[i].toString()))       return constants[i];
    }
    if (type == CharSequence.class)     return string;
    throw new SerializationException("Unable to convert value to required type: " + value + " ("+ type.getName()+ ")");
  }
  return null;
}
