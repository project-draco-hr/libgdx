{
  this.assetName=modelAsset;
  numMeshes=md5model.meshes.length;
  boolean cached=false;
  if (animator == null) {
    animator=new KeyframeAnimator(numMeshes,sampleRate);
    target=new Mesh[numMeshes];
    visible=new boolean[numMeshes];
    for (int i=0; i < visible.length; i++) {
      visible[i]=true;
    }
  }
  if (animations == null) {
    animations=new ObjectMap<String,KeyframeAnimation>();
  }
  String key=modelAsset + "_" + animKey;
  KeyframeAnimation a=null;
  if (animations.containsKey(key)) {
    a=animations.get(key);
    a.addRef();
    cached=true;
  }
  animationRefs.add(key);
  md5animator.setAnimation(md5animation,WrapMode.Clamp);
  float len=md5animation.frames.length * md5animation.secondsPerFrame;
  int numSamples=(int)(len / sampleRate) + 1;
  if (!cached) {
    a=new KeyframeAnimation(md5animation.name,numSamples,len,sampleRate);
    animations.put(key,a);
  }
  md5animator.update(0.1f);
  md5renderer.setSkeleton(md5animator.getSkeleton());
  int i=0;
  int numVertices=0, numIndices=0;
  for (float t=0; t < len; t+=sampleRate) {
    Keyframe k=null;
    if (!cached) {
      k=new Keyframe();
      k.vertices=new float[numMeshes][];
      k.indices=new short[numMeshes][];
      if (taggedJointNames.size() > 0) {
        k.taggedJointPos=new Vector3[taggedJointNames.size()];
        k.taggedJoint=new Quaternion[taggedJointNames.size()];
      }
    }
    for (int m=0; m < numMeshes; m++) {
      float vertices[]=md5renderer.getVertices(m);
      short indices[]=md5renderer.getIndices(m);
      numVertices=vertices.length;
      numIndices=indices.length;
      if (!cached) {
        k.vertices[m]=clone(vertices);
        k.indices[m]=clone(indices);
      }
      if (target[m] == null) {
        animator.setKeyframeDimensions(m,numVertices,numIndices);
        animator.setNumTaggedJoints(taggedJointNames.size());
        VertexAttributes attribs=md5renderer.getMesh().getVertexAttributes();
        target[m]=new Mesh(false,numVertices,numIndices,attribs);
        if (target[m].getVertexSize() / 4 != KeyframeAnimator.sStride)         throw new GdxRuntimeException("Mesh vertexattributes != 8 - is this a valid MD5 source mesh?");
      }
    }
    if (!cached) {
      MD5Joints skel=md5animator.getSkeleton();
      for (int tj=0; tj < taggedJointNames.size(); tj++) {
        String name=taggedJointNames.get(tj);
        for (int j=0; j < skel.numJoints; j++) {
          if (name.equals(skel.names[j])) {
            int idx=j * 8;
            float x=skel.joints[idx + 1];
            float y=skel.joints[idx + 2];
            float z=skel.joints[idx + 3];
            k.taggedJointPos[tj]=new Vector3(x,y,z);
            float qx=skel.joints[idx + 4];
            float qy=skel.joints[idx + 5];
            float qz=skel.joints[idx + 6];
            float qw=skel.joints[idx + 7];
            k.taggedJoint[tj]=new Quaternion(qx,qy,qz,qw);
            break;
          }
        }
      }
      a.keyframes[i]=k;
    }
    md5animator.update(sampleRate);
    md5renderer.setSkeleton(md5animator.getSkeleton());
    i++;
  }
  if (cached) {
  }
 else {
  }
  return a;
}
