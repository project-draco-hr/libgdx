{
  if (!Gdx.graphics.isGL20Available())   throw new GdxRuntimeException("This shader requires OpenGL ES 2.0");
  ShaderProgram.pedantic=false;
  this.lighting=lighting;
  this.directionalLights=new DirectionalLight[lighting && numDirectional > 0 ? numDirectional : 0];
  for (int i=0; i < directionalLights.length; i++)   directionalLights[i]=new DirectionalLight();
  this.pointLights=new PointLight[lighting && numPoint > 0 ? numPoint : 0];
  for (int i=0; i < pointLights.length; i++)   pointLights[i]=new PointLight();
  String prefix="";
  this.mask=mask;
  this.attributes=attributes;
  if (!ignoreUnimplemented && (implementedFlags & mask) != mask)   throw new GdxRuntimeException("Some attributes not implemented yet (" + mask + ")");
  if ((attributes & Usage.Color) == Usage.Color)   prefix+="#define colorFlag\n";
  if ((attributes & Usage.Normal) == Usage.Normal) {
    prefix+="#define normalFlag\n";
    if (lighting) {
      prefix+="#define lightingFlag\n";
      prefix+="#define ambientCubemapFlag\n";
      prefix+="#define numDirectionalLights " + numDirectional + "\n";
      prefix+="#define numPointLights " + numPoint + "\n";
    }
  }
  if (can(BlendingAttribute.Type))   prefix+="#define " + BlendingAttribute.Alias + "Flag\n";
  if (can(TextureAttribute.Diffuse))   prefix+="#define " + TextureAttribute.DiffuseAlias + "Flag\n";
  if (can(ColorAttribute.Diffuse))   prefix+="#define " + ColorAttribute.DiffuseAlias + "Flag\n";
  if (can(ColorAttribute.Specular))   prefix+="#define " + ColorAttribute.SpecularAlias + "Flag\n";
  if (can(FloatAttribute.Shininess))   prefix+="#define " + FloatAttribute.ShininessAlias + "Flag\n";
  program=new ShaderProgram(prefix + vertexShader,prefix + fragmentShader);
  if (!program.isCompiled())   throw new GdxRuntimeException(program.getLog());
  projTransLoc=program.getUniformLocation(PROJECTION_TRANSFORM);
  modelTransLoc=program.getUniformLocation(MODEL_TRANSFORM);
  normalTransLoc=program.getUniformLocation(NORMAL_TRANSFORM);
  cameraPosLoc=program.getUniformLocation(CAMERA_POSITION);
  cameraDirLoc=program.getUniformLocation(CAMERA_DIRECTION);
  cameraUpLoc=program.getUniformLocation(CAMERA_UP);
  diffuseTextureLoc=!can(TextureAttribute.Diffuse) ? -1 : program.getUniformLocation(TextureAttribute.DiffuseAlias);
  diffuseColorLoc=!can(ColorAttribute.Diffuse) ? -1 : program.getUniformLocation(ColorAttribute.DiffuseAlias);
  specularColorLoc=!can(ColorAttribute.Specular) ? -1 : program.getUniformLocation(ColorAttribute.SpecularAlias);
  shininessLoc=!can(FloatAttribute.Shininess) ? -1 : program.getUniformLocation(FloatAttribute.ShininessAlias);
  ambientCubemapLoc=lighting ? program.fetchUniformLocation("ambientCubemap") : -1;
  dirLightsLoc=lighting ? program.fetchUniformLocation("directionalLights[0].color") : -1;
  dirLightsColorOffset=dirLightsLoc >= 0 ? 0 : -1;
  dirLightsDirectionOffset=dirLightsLoc >= 0 ? program.fetchUniformLocation("directionalLights[0].direction") - dirLightsLoc : -1;
  dirLightsSize=(numDirectional > 1 && dirLightsLoc >= 0) ? program.fetchUniformLocation("directionalLights[1].color") - dirLightsLoc : -1;
  pointLightsLoc=lighting ? program.fetchUniformLocation("pointLights[0].color") : -1;
  pointLightsColorOffset=pointLightsLoc >= 0 ? 0 : -1;
  pointLightsPositionOffset=pointLightsLoc >= 0 ? program.fetchUniformLocation("pointLights[0].position") - pointLightsLoc : -1;
  pointLightsIntensityOffset=pointLightsLoc >= 0 ? program.fetchUniformLocation("pointLights[0].intensity") - pointLightsLoc : -1;
  pointLightsSize=(numPoint > 1 && pointLightsLoc >= 0) ? program.fetchUniformLocation("pointLights[1].color") - pointLightsLoc : -1;
}
