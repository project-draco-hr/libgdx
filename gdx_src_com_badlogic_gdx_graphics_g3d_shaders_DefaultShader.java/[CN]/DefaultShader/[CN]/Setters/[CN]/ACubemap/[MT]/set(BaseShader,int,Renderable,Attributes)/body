{
  if (renderable.environment == null)   shader.program.setUniform4fv(shader.loc(inputID),ones,0,ones.length);
 else {
    renderable.worldTransform.getTranslation(tmpV1);
    if (combinedAttributes.has(ColorAttribute.AmbientLight))     cacheAmbientCubemap.set(((ColorAttribute)combinedAttributes.get(ColorAttribute.AmbientLight)).color);
    if (combinedAttributes.has(DirectionalLightsAttribute.Type)) {
      Array<DirectionalLight> lights=((DirectionalLightsAttribute)combinedAttributes.get(DirectionalLightsAttribute.Type)).lights;
      for (int i=dirLightsOffset; i < lights.size; i++)       cacheAmbientCubemap.add(lights.get(i).color,lights.get(i).direction);
    }
    if (combinedAttributes.has(PointLightsAttribute.Type)) {
      Array<PointLight> lights=((PointLightsAttribute)combinedAttributes.get(PointLightsAttribute.Type)).lights;
      for (int i=pointLightsOffset; i < lights.size; i++)       cacheAmbientCubemap.add(lights.get(i).color,lights.get(i).position,tmpV1,lights.get(i).intensity);
    }
    cacheAmbientCubemap.clamp();
    final float data[]=cacheAmbientCubemap.data;
    for (int i=0; i < 6; i++) {
      tmp[i * 4 + 0]=data[i * 3 + 0];
      tmp[i * 4 + 1]=data[i * 3 + 1];
      tmp[i * 4 + 2]=data[i * 3 + 2];
      tmp[i * 4 + 3]=1f;
    }
    shader.program.setUniform4fv(shader.loc(inputID),tmp,0,tmp.length);
  }
}
