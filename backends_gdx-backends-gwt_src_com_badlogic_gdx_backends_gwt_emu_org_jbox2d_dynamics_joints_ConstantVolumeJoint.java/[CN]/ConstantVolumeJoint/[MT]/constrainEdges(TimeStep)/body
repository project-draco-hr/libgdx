{
  float perimeter=0.0f;
  for (int i=0; i < bodies.length; ++i) {
    final int next=(i == bodies.length - 1) ? 0 : i + 1;
    float dx=bodies[next].getWorldCenter().x - bodies[i].getWorldCenter().x;
    float dy=bodies[next].getWorldCenter().y - bodies[i].getWorldCenter().y;
    float dist=MathUtils.sqrt(dx * dx + dy * dy);
    if (dist < Settings.EPSILON) {
      dist=1.0f;
    }
    normals[i].x=dy / dist;
    normals[i].y=-dx / dist;
    perimeter+=dist;
  }
  final Vec2 delta=pool.popVec2();
  float deltaArea=targetVolume - getArea();
  float toExtrude=0.5f * deltaArea / perimeter;
  boolean done=true;
  for (int i=0; i < bodies.length; ++i) {
    final int next=(i == bodies.length - 1) ? 0 : i + 1;
    delta.set(toExtrude * (normals[i].x + normals[next].x),toExtrude * (normals[i].y + normals[next].y));
    float norm=delta.length();
    if (norm > Settings.maxLinearCorrection) {
      delta.mulLocal(Settings.maxLinearCorrection / norm);
    }
    if (norm > Settings.linearSlop) {
      done=false;
    }
    bodies[next].m_sweep.c.x+=delta.x;
    bodies[next].m_sweep.c.y+=delta.y;
    bodies[next].synchronizeTransform();
  }
  pool.pushVec2(1);
  return done;
}
