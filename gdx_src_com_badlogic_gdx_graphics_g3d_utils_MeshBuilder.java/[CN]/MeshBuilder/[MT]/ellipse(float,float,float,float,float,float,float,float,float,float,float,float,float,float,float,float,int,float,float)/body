{
  if (innerWidth <= 0 || innerHeight <= 0) {
    ensureTriangles(divisions + 2,divisions);
  }
 else   if (innerWidth == width && innerHeight == height) {
    ensureVertices(divisions + 1);
    if (primitiveType != GL10.GL_LINES)     throw new GdxRuntimeException("Incorrect primitive type : expect GL_LINES because innerWidth == width && innerHeight == height");
  }
 else {
    ensureRectangleIndices(divisions + 1);
  }
  final float ao=MathUtils.degreesToRadians * angleFrom;
  final float step=(MathUtils.degreesToRadians * (angleTo - angleFrom)) / divisions;
  final Vector3 sxEx=tempV1.set(tangentX,tangentY,tangentZ).scl(width * 0.5f);
  final Vector3 syEx=tempV2.set(binormalX,binormalY,binormalZ).scl(height * 0.5f);
  final Vector3 sxIn=tempV3.set(tangentX,tangentY,tangentZ).scl(innerWidth * 0.5f);
  final Vector3 syIn=tempV4.set(binormalX,binormalY,binormalZ).scl(innerHeight * 0.5f);
  VertexInfo currIn=vertTmp3.set(null,null,null,null);
  currIn.hasUV=true;
  currIn.uv.set(.5f,.5f);
  currIn.hasPosition=currIn.hasNormal=true;
  currIn.position.set(centerX,centerY,centerZ);
  currIn.normal.set(normalX,normalY,normalZ);
  VertexInfo currEx=vertTmp4.set(null,null,null,null);
  currEx.hasUV=true;
  currEx.uv.set(.5f,.5f);
  currEx.hasPosition=currEx.hasNormal=true;
  currEx.position.set(centerX,centerY,centerZ);
  currEx.normal.set(normalX,normalY,normalZ);
  final short center=vertex(currEx);
  float angle=0f;
  for (int i=0; i <= divisions; i++) {
    angle=ao + step * i;
    final float x=MathUtils.cos(angle);
    final float y=MathUtils.sin(angle);
    currEx.position.set(centerX,centerY,centerZ).add(sxEx.x * x + syEx.x * y,sxEx.y * x + syEx.y * y,sxEx.z * x + syEx.z * y);
    currEx.uv.set(.5f + .5f * x,.5f + .5f * y);
    vertex(currEx);
    if (innerWidth <= 0 || innerHeight <= 0) {
      if (i != 0)       triangle((short)(vindex - 1),(short)(vindex - 2),center);
    }
 else     if (innerWidth == width && innerHeight == height) {
      if (i != 0)       line((short)(vindex - 1),(short)(vindex - 2));
    }
 else {
      currIn.position.set(centerX,centerY,centerZ).add(sxIn.x * x + syIn.x * y,sxIn.y * x + syIn.y * y,sxIn.z * x + syIn.z * y);
      currIn.uv.set(.5f + .5f * x,.5f + .5f * y);
      vertex(currIn);
      if (i != 0)       rect((short)(vindex - 1),(short)(vindex - 2),(short)(vindex - 4),(short)(vindex - 3));
    }
  }
}
