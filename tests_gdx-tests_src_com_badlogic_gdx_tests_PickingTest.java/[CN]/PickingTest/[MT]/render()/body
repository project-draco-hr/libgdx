{
  GL10 gl=Gdx.gl10;
  gl.glClearColor(0.2f,0.2f,0.2f,1.0f);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  gl.glEnable(GL10.GL_DEPTH_TEST);
  cam.update();
  gl.glViewport(VP_X,VP_Y,VP_WIDTH,VP_HEIGHT);
  Ray pickRay=null;
  if (Gdx.input.isTouched()) {
    pickRay=cam.getPickRay(Gdx.input.getX(),Gdx.input.getY(),VP_X,VP_Y,VP_WIDTH,VP_HEIGHT);
  }
  boolean intersected=false;
  modelBatch.begin(cam);
  for (int i=0; i < instances.length; i++) {
    instances[i].transform.getTranslation(tempVector);
    if (pickRay != null && Intersector.intersectRaySphere(pickRay,tempVector,1,intersection)) {
      ((ColorAttribute)instances[i].materials.get(0).get(ColorAttribute.Diffuse)).color.set(Color.RED);
      intersected=true;
    }
 else {
      ((ColorAttribute)instances[i].materials.get(0).get(ColorAttribute.Diffuse)).color.set(Color.WHITE);
    }
    modelBatch.render(instances[i]);
  }
  modelBatch.end();
  Gdx.gl.glViewport(0,0,Gdx.graphics.getWidth(),Gdx.graphics.getHeight());
  batch.begin();
  if (intersected) {
    cam.project(intersection,VP_X,VP_Y,VP_WIDTH,VP_HEIGHT);
    batch.draw(logo,intersection.x,intersection.y);
  }
  batch.end();
  renderer.begin(GL10.GL_LINE_LOOP);
  renderer.color(1,1,1,1);
  renderer.vertex(VP_X,VP_Y,0);
  renderer.color(1,1,1,1);
  renderer.vertex(VP_X + VP_WIDTH,VP_Y,0);
  renderer.color(1,1,1,1);
  renderer.vertex(VP_X + VP_WIDTH,VP_Y + VP_HEIGHT,0);
  renderer.color(1,1,1,1);
  renderer.vertex(VP_X,VP_Y + VP_HEIGHT,0);
  renderer.end();
  if (Gdx.input.isKeyPressed(Keys.A))   cam.rotate(20 * Gdx.graphics.getDeltaTime(),0,1,0);
  if (Gdx.input.isKeyPressed(Keys.D))   cam.rotate(-20 * Gdx.graphics.getDeltaTime(),0,1,0);
}
