{
  if (dt > 0)   --dt;
  if (st > 0) {
    --st;
  }
  if (waitForKeypress) {
    waitForKeypress=false;
  }
  int hb=mem[pc++] & 0xff;
  int lb=mem[pc++] & 0xff;
  int n1=(hb >>> 4);
  int n2=(hb & 0xf);
  int n3=(lb >>> 4);
  int n4=(lb & 0xf);
switch (n1) {
case 0x0:
{
      if (hb == 0) {
        if (lb == 0xe0) {
          Arrays.fill(fbuf,(byte)0);
        }
        if (lb == 0xee) {
          pc=stack[sp];
          --st;
        }
      }
 else {
        pc=(n2 << 8) | lb;
      }
      break;
    }
case 0x1:
{
    pc=(n2 << 8) | lb;
    break;
  }
case 0x2:
{
  ++st;
  stack[sp]=pc;
  pc=(n2 << 8) | lb;
  break;
}
case 0x3:
{
if (v[n2] == lb) pc+=2;
break;
}
case 0x4:
{
if (v[n2] != lb) pc+=2;
break;
}
case 0x5:
{
if (v[n2] == v[n3]) pc+=2;
break;
}
case 0x6:
{
v[n2]=lb;
break;
}
case 0x7:
{
v[n2]=(v[n2] + lb) & 0xff;
break;
}
case 0x8:
{
switch (n4) {
case 0x0:
v[n2]=v[n3];
break;
case 0x1:
v[n2]=v[n2] | v[n3];
break;
case 0x2:
v[n2]=v[n2] & v[n3];
break;
case 0x3:
v[n2]=v[n2] ^ v[n3];
break;
case 0x4:
int result=v[n2]=v[n2] + v[n3];
v[0xf]=result > 0xff ? 1 : 0;
break;
case 0x5:
v[0xf]=v[n2] > v[n3] ? 1 : 0;
v[n2]=(v[n2] - v[n3]) & 0xff;
break;
case 0x6:
v[0xf]=(v[n2] & 0x1) != 0 ? 1 : 0;
v[n2]=v[n2] >>> 1;
break;
case 0x7:
v[0xf]=v[n3] > v[n2] ? 1 : 0;
v[n2]=(v[n3] - v[n2]) & 0xff;
break;
case 0xe:
v[0xf]=(v[n2] & 0x80) != 0 ? 1 : 0;
v[n2]=v[n2] << 1;
break;
}
break;
}
case 0x9:
{
if (v[n2] != v[n3]) pc+=2;
break;
}
case 0xa:
{
idx=(n2 << 8) | lb;
break;
}
case 0xb:
{
pc=((n2 << 8) | lb) + v[0];
break;
}
case 0xc:
{
v[n2]=rand.nextInt(0xff + 1) & lb;
break;
}
case 0xd:
{
displaySprite(v[n2],v[n2],idx,n4,mem,fbuf);
break;
}
case 0xe:
{
switch (lb) {
case 0x9e:
if (keys[v[n2]]) pc+=2;
break;
case 0xa1:
if (!keys[v[n2]]) pc+=2;
break;
}
break;
}
case 0xf:
{
switch (lb) {
case 0x07:
v[n2]=dt;
break;
case 0x0a:
waitForKeypress=true;
keyRegister=n2;
break;
case 0x15:
dt=v[n2];
break;
case 0x18:
st=v[n2];
break;
case 0x1e:
idx=(idx + v[n2]) & 0xffff;
break;
case 0x29:
idx=(5 * v[n2]) & 0xffff;
break;
case 0x33:
break;
case 0x55:
System.arraycopy(v,0,mem,idx,v[n2]);
break;
case 0x65:
System.arraycopy(mem,idx,v,0,v[n2]);
break;
}
break;
}
default :
throw new RuntimeException("opcode " + Integer.toHexString(hb) + ", "+ Integer.toHexString(lb)+ " unknown");
}
}
